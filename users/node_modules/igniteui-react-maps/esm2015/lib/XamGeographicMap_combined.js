/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { SeriesViewer } from "igniteui-react-charts";
import { IMapRenderDeferralHandler_$type } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { MapResizeBehavior_$type } from "./MapResizeBehavior";
import { Rect } from "igniteui-react-core";
import { Base, typeCast, enumGetBox, Point_$type, fromEnum, runOn, delegateRemove, delegateCombine, markType, markDep, INotifyPropertyChanged_$type, PropertyChangedEventArgs, String_$type, IEnumerable_$type } from "igniteui-react-core";
import { NumericXAxis } from "igniteui-react-charts";
import { NumericYAxis } from "igniteui-react-charts";
import { SphericalMercatorVerticalScaler } from "./SphericalMercatorVerticalScaler";
import { Control } from "igniteui-react-core";
import { SphericalMercatorHorizontalScaler } from "./SphericalMercatorHorizontalScaler";
import { ScalerParams } from "igniteui-react-charts";
import { Brush } from "igniteui-react-core";
import { SeriesViewerView } from "igniteui-react-charts";
import { MathUtil } from "igniteui-react-core";
import { ImageTilesReadyEventArgs } from "./ImageTilesReadyEventArgs";
import { ItfConverter } from "igniteui-react-core";
import { ChartVisualData } from "igniteui-react-charts";
import { RectData } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, intDivide, isNaN_ } from "igniteui-react-core";
import { XamMultiScaleImage } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { ImagesChangedEventArgs } from "./ImagesChangedEventArgs";
import { HostSeriesView } from "./HostSeriesView";
import { GeographicMapSeriesHost } from "./GeographicMapSeriesHost";
import { ScatterAreaSeries } from "igniteui-react-charts";
import { OpenStreetMapTileSource } from "igniteui-react-core";
/**
 * @hidden
 */
export let XamGeographicMap = /*@__PURE__*/ (() => {
    class XamGeographicMap extends SeriesViewer {
        constructor() {
            super();
            this.nv = null;
            this.nr = 0;
            this.oy = null;
            this.nf = null;
            this.nb = null;
            this.nd = null;
            this.nh = null;
            this.ou = { $type: Point_$type, x: NaN, y: NaN };
            this.o1 = null;
            this.nq = 1;
            this.imageTilesReady = null;
            this.nl = null;
            this.o0 = Rect.empty;
            this.nr = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.bottom) - SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
            this.ab = XamGeographicMap.$;
            this.backgroundContent = new OpenStreetMapImagery();
            let a = ((() => {
                let $ret = new NumericXAxis();
                $ret.bh = this;
                return $ret;
            })());
            a.b8 = true;
            this.nc = a;
            this.nc.ln = new SphericalMercatorHorizontalScaler();
            let b = ((() => {
                let $ret = new NumericYAxis();
                $ret.bh = this;
                return $ret;
            })());
            b.b8 = true;
            this.ne = b;
            this.ne.ln = new SphericalMercatorVerticalScaler();
            this.ob();
            this.oi();
            this.hs();
        }
        provideContainer(a) {
            super.provideContainer(a);
            this.nc.provideRenderer(a);
            this.ne.provideRenderer(a);
        }
        hs() {
            super.hs();
            this.nk.fm(this.ea);
        }
        c3() {
            return this.no;
        }
        c4() {
            return this.no;
        }
        get o3() {
            return this.oy;
        }
        set o3(a) {
            let b = Rect.l_op_Inequality(this.oy, a);
            if (b) {
                let c = this.oy;
                this.oy = a;
                this.ji("ActualWorldRect", c, a);
            }
        }
        o7() {
            return this.o3;
        }
        ob() {
            if (this.pf.isEmpty) {
                return;
            }
            this.o3 = this.pd(this.pf, true);
        }
        pd(a, b) {
            let c = a.top;
            let d = a.left;
            let e = a.width;
            let f = a.height;
            let g = SphericalMercatorVerticalScaler.am(a.bottom);
            let h = SphericalMercatorVerticalScaler.am(a.top);
            let i = g - h;
            let j = a.width / XamGeographicMap.oz.width;
            let k = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
            let l = i / j;
            if (i / j > this.nr) {
                let m = i / this.nr;
                let n = m - j;
                d = d - (n / 2) * XamGeographicMap.oz.width;
                e = m * XamGeographicMap.oz.width;
                if (b) {
                    if (d < XamGeographicMap.oz.left) {
                        d += (XamGeographicMap.oz.left - d);
                    }
                    else if ((d + e) > XamGeographicMap.oz.right) {
                        d -= ((d + e) - XamGeographicMap.oz.right);
                    }
                }
            }
            else if (i / j < this.nr) {
                let o = this.nr * j;
                let p = o - i;
                let q = h - (p / 2);
                let r = g + (p / 2);
                if (b) {
                    if (q < k) {
                        q += (k - q);
                        r += (k - q);
                    }
                    else if (r > (k + this.nr)) {
                        q -= ((r) - (k + this.nr));
                        r -= ((r) - (k + this.nr));
                    }
                }
                c = SphericalMercatorVerticalScaler.aq(q);
                f = SphericalMercatorVerticalScaler.aq(r) - c;
            }
            let s = new Rect(0, d, c, e, f);
            return s;
        }
        get backgroundContent() {
            return this.nf;
        }
        set backgroundContent(a) {
            let b = a != this.backgroundContent;
            if (b) {
                let c = this.backgroundContent;
                this.nf = a;
                this.ji("BackgroundContent", c, a);
            }
        }
        get nc() {
            return this.nb;
        }
        set nc(a) {
            let b = a != this.nc;
            if (b) {
                let c = this.nc;
                this.nb = a;
                this.ji("XAxis", c, a);
            }
        }
        get ne() {
            return this.nd;
        }
        set ne(a) {
            let b = a != this.ne;
            if (b) {
                let c = this.ne;
                this.nd = a;
                this.ji("YAxis", c, a);
            }
        }
        getZoomRectFromGeoRect(a) {
            return this.getZoomFromGeographicRect(a);
        }
        ol(a) {
            this.m6 = a;
        }
        ok(a) {
            this.pf = a;
        }
        getZoomFromGeographicRect(a) {
            return this.o5(a, true, 0);
        }
        o4(a, b) {
            return this.o5(a, false, b);
        }
        o5(a, b, c) {
            let d = a;
            if (b) {
                d = this.pd(a, false);
            }
            let e = this.nc;
            let f = this.ne;
            let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, e.ca);
            g.c = this.mv;
            let h = new ScalerParams(1, XamGeographicMap.o2, this.m5, f.ca);
            h.c = this.mv;
            let i = this.nc.dy(d.left, g);
            let j = this.nc.dy(d.right, g);
            let k = this.ne.dy(d.top, h);
            let l = this.ne.dy(d.bottom, h);
            let m = (i - c) / this.m5.width;
            let n = (l - c) / this.m5.height;
            let o = (j - i + (c * 2)) / this.m5.width;
            let p = (k - l + (c * 2)) / this.m5.height;
            let q = new Rect(0, m, n, o, p);
            q.intersect(XamGeographicMap.o2);
            if (q.isEmpty) {
                q = XamGeographicMap.o2;
            }
            return q;
        }
        getZoomFromGeographicPoints(a, b) {
            let c = a.x;
            let d = b.y;
            let e = b.x - a.x;
            let f = a.y - b.y;
            if (e < 0 || f < 0) {
                return XamGeographicMap.o2;
            }
            else {
                let g = new Rect(0, c, d, e, f);
                return this.getZoomFromGeographicRect(g);
            }
        }
        o9(a) {
            let b = this.nc;
            let c = this.ne;
            let d = new ScalerParams(1, a, this.m5, b.ca);
            d.c = this.mv;
            let e = new ScalerParams(1, a, this.m5, c.ca);
            e.c = this.mv;
            let f = this.mu;
            let g = b.d1(f.left, d);
            let h = c.d1(f.top, e);
            let i = b.d1(f.right, d);
            let j = c.d1(f.bottom, e);
            let k = i - g;
            let l = h - j;
            let m = new Rect(0, g, j, k, l);
            m.intersect(XamGeographicMap.oz);
            if (m.isEmpty) {
                m = XamGeographicMap.oz;
            }
            return m;
        }
        ov(a) {
            let b = this.nc.km(a.x);
            let c = this.ne.km(a.y);
            return { $type: Point_$type, x: b, y: c };
        }
        ow(a) {
            let b = this.nc.ed(a.x);
            let c = this.ne.ed(a.y);
            return { $type: Point_$type, x: b, y: c };
        }
        ox(a) {
            return this.ow(a);
        }
        n8() {
            let a = typeCast(GeographicMapImagery.$, this.backgroundContent);
            if (a != null) {
                a.clearTileCache();
            }
        }
        oe(a) {
        }
        mb(a) {
            return this.nk.fq(a);
        }
        mc(a) {
            return this.nk.fr(a);
        }
        dh() {
            return true;
        }
        og() {
            this.nk.d7();
            for (let a of fromEnum(this.series)) {
                a.jn();
            }
        }
        oj() {
            if (this.nj == 2) {
                if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                    let a = this.nc.km(this.m5.left + (this.m5.width / 2));
                    let b = this.ne.km(this.m5.top + (this.m5.height / 2));
                    this.ou = { $type: Point_$type, x: a, y: b };
                }
            }
            else {
                if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                    let c = this.nc.km(this.m5.left);
                    let d = this.ne.km(this.m5.top);
                    this.ou = { $type: Point_$type, x: c, y: d };
                }
            }
        }
        of() {
            if (isNaN_(this.ou.x) || isNaN_(this.ou.y)) {
                this.oj();
            }
            let a = this.ou.x;
            let b = this.ou.y;
            if (!isNaN_(a) && !isNaN_(b)) {
                let c = this.mr.left;
                let d = this.mr.top;
                let e = this.mr.width;
                let f = this.mr.height;
                if (e > this.o1.width) {
                }
                else {
                    let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
                    g.c = this.mv;
                    let h = this.nc.dy(a, g);
                    if (this.nj == 2) {
                        let i = h / this.m5.width;
                        c = i - (e / 2);
                    }
                    else {
                        c = h / this.m5.width;
                    }
                    if (c + e > this.o1.right) {
                        c = this.o1.right - e;
                    }
                    else if (c < this.o1.left) {
                        c = this.o1.left;
                    }
                }
                if (f > this.o1.height) {
                }
                else {
                    let j = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
                    j.c = this.mv;
                    let k = this.ne.dy(b, j);
                    if (this.nj == 2) {
                        let l = k / this.m5.height;
                        d = l - (f / 2);
                    }
                    else {
                        d = k / this.m5.height;
                    }
                    if (d + f > this.o1.bottom) {
                        d = this.o1.bottom - f;
                    }
                    else if (d < this.o1.top) {
                        d = this.o1.top;
                    }
                }
                this.km(new Rect(0, c, d, e, f), false);
            }
        }
        get_cx() {
            return true;
        }
        ms() {
            let a = super.ms();
            if (this.nc == null || this.ne == null) {
                return a;
            }
            let b = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
            b.c = this.mv;
            let c = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
            c.c = this.mv;
            let d = this.nc.dy(XamGeographicMap.oz.left, b);
            let e = this.nc.dy(XamGeographicMap.oz.right, b);
            let f = this.ne.dy(XamGeographicMap.oz.top, c);
            let g = this.ne.dy(XamGeographicMap.oz.bottom, c);
            this.o1 = new Rect(0, d / this.m5.width, g / this.m5.height, (e - d) / this.m5.width, (f - g) / this.m5.height);
            let h = a.left;
            let i = a.top;
            if (this.m6.width > this.o1.width) {
                h = 0.5 - (this.m6.width / 2);
            }
            else if (h + a.width > this.o1.right) {
                h = this.o1.right - this.m6.width;
            }
            else if (h < this.o1.left) {
                h = this.o1.left;
            }
            if (this.m6.height > this.o1.height) {
                i = 0.5 - (this.m6.height / 2);
            }
            else if (i + this.m6.height > this.o1.bottom) {
                i = this.o1.bottom - this.m6.height;
            }
            else if (i < this.o1.top) {
                i = this.o1.top;
            }
            let j = new Rect(0, h, i, a.width, a.height);
            if (this.nn) {
                let k = this.o4(this.pf, 1);
                k = this.o6(k);
                let l = j.left + j.width / 2;
                let m = j.top + j.height / 2;
                if (j.width > k.width) {
                    let n = j.height / j.width;
                    let o = k.width;
                    let p = n * o;
                    j = new Rect(0, l - o / 2, m - p / 2, o, p);
                }
                if (j.height > k.height) {
                    let q = j.width / j.height;
                    let r = k.height;
                    let s = q * r;
                    j = new Rect(0, l - s / 2, m - r / 2, s, r);
                }
                if (j.left < k.left) {
                    j = new Rect(0, k.left, j.top, j.width, j.height);
                }
                if (j.top < k.top) {
                    j = new Rect(0, j.left, k.top, j.width, j.height);
                }
                if (j.right > k.right) {
                    j = new Rect(0, k.right - j.width, j.top, j.width, j.height);
                }
                if (j.bottom > k.bottom) {
                    j = new Rect(0, j.left, k.bottom - j.height, j.width, j.height);
                }
            }
            return j;
        }
        o6(a) {
            let b = this.ex;
            let c = 0.5 * (a.left + a.right);
            let d = 0.5 * (a.top + a.bottom);
            let e = a.width;
            let f = a.height;
            let g = MathUtil.b(a.width, b, 1);
            let h = MathUtil.b(a.height, b, 1);
            let i = this.m5;
            let j = i.width / i.height;
            let k = g * i.width;
            let l = h * i.height;
            let m = k / l;
            if (m != j) {
                if (l * j > k) {
                    k = l * j;
                    g = k / i.width;
                }
                else {
                    l = k / j;
                    h = l / i.height;
                }
            }
            let n = g != e;
            let o = h != f;
            let p = n ? c - 0.5 * g : a.left;
            let q = o ? d - 0.5 * h : a.top;
            let r = n ? c + 0.5 * g : a.right;
            let s = o ? d + 0.5 * h : a.bottom;
            if (p < 0) {
                p = 0;
                r = p + g;
            }
            if (r > 1) {
                r = 1;
                p = r - g;
            }
            if (q < 0) {
                q = 0;
                s = q + h;
            }
            if (s > 1) {
                s = 1;
                q = s - h;
            }
            return new Rect(0, p, q, r - p, s - q);
        }
        mt(a) {
            super.mt(this.m5);
            if (a.isEmpty) {
                return Rect.empty;
            }
            let b;
            if (a.width > a.height) {
                let c = intDivide(truncate((a.width - a.height)), 2);
                b = new Rect(0, a.left + c, a.top, a.height, a.height);
            }
            else {
                let d = intDivide(truncate((a.height - a.width)), 2);
                b = new Rect(0, a.left, a.top + d, a.width, a.width);
            }
            return b;
        }
        o8(a) {
            return this.mt(a);
        }
        bm() {
            return new XamGeographicMapView(this);
        }
        l7(a) {
            return this.nk.fp(a);
        }
        md(a) {
            return this.nk.fs(a);
        }
        oa(a) {
            if (a != null) {
                a.bh = this;
            }
        }
        i2(a) {
            super.i2(a);
            this.nk = a;
        }
        jd(a, b) {
            super.jd(a, b);
            this.kb(this.nc);
            this.kb(this.ne);
            if (Rect.l_op_Inequality(a, b)) {
                this.of();
            }
            if (this.nn) {
                this.mr = this.ms();
            }
            this.om();
        }
        get ns() {
            return this.nq;
        }
        set ns(a) {
            let b = this.nq;
            this.nq = a;
            this.ji("ActualWindowScale", b, this.nq);
        }
        eg() {
            return this.ns;
        }
        eh() {
            return this.ns;
        }
        ka() {
            super.ka();
            let a = Math.min(this.mr.width, this.mr.height);
            this.ns = a;
        }
        je(a, b, c, d) {
            super.je(a, b, c, d);
            switch (b) {
                case "WindowRect":
                    this.oj();
                    break;
                case XamGeographicMap.$$p[2]:
                    this.mr = this.ms();
                    break;
                case "BackgroundContent":
                    if (this.nh != null) {
                        let e = this.nh;
                        e.imageTilesReady = delegateRemove(e.imageTilesReady, runOn(this, this.oc));
                        this.nh.deferralHandler = null;
                    }
                    this.nh = typeCast(GeographicMapImagery.$, this.backgroundContent);
                    if (this.nh != null) {
                        let f = this.nh;
                        f.imageTilesReady = delegateCombine(f.imageTilesReady, runOn(this, this.oc));
                        this.nh.deferralHandler = this;
                    }
                    this.nk.fl(typeCast(GeographicMapImagery.$, c), typeCast(GeographicMapImagery.$, d));
                    if (this.nh != null) {
                        this.nh.geographicMap = this;
                        this.nk.fi(this.mr);
                        this.nk.fm(this.ea);
                    }
                    break;
                case "YAxis":
                case "XAxis":
                    this.oh(c);
                    this.oa(d);
                    break;
                case XamGeographicMap.$$p[4]:
                    if (!this.nm) {
                        this.m6 = XamGeographicMap.o2;
                    }
                    this.ob();
                    this.oi();
                    this.oj();
                    this.mr = this.ms();
                    this.nk.fj();
                    break;
                case "ActualWindowRect":
                    this.nk.fi(this.mr);
                    break;
                case "ActualWorldRect":
                    for (let g of fromEnum(this.series)) {
                        g.je(false);
                    }
                    break;
                case XamGeographicMap.$$p[3]:
                    this.ns = this.nt;
                    break;
                case "ActualWindowScale":
                    if (!this.dg) {
                        this.kl(this.eg(), this.eh());
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.nk.fm(this.ea);
                    break;
                case XamGeographicMap.$$p[5]:
                    this.kh();
                    break;
            }
        }
        oc(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new ImageTilesReadyEventArgs());
            }
        }
        oh(a) {
            if (a != null) {
                a.bh = null;
            }
        }
        oi() {
            if (this.nc != null) {
                this.nc.kj = this.o3.left;
                this.nc.ki = this.o3.right;
            }
            if (this.ne != null) {
                this.ne.kj = this.o3.top;
                this.ne.ki = this.o3.bottom;
            }
            this.nc.co(true);
            this.ne.co(true);
        }
        getFontInfo() {
            this.nl = this.nk.ff;
            return this.nl;
        }
        l6() {
            return this.nk.fn;
        }
        getFontBrush() {
            return this.nk.fo;
        }
        j5(a, b) {
            if (typeCast(ItfConverter.$, b) !== null) {
                let c = b;
                let d = a;
                d.itemsSource = c.triangulationSource.points;
                d.mc = c.triangulationSource.triangles;
            }
            else {
                super.j5(a, b);
            }
        }
        register(a, b) {
            this.jv(a, b);
        }
        unRegister(a) {
            this.j9(a);
        }
        deferredRefresh() {
            this.hh();
        }
        deferAction(a) {
            if (this.nv != null) {
                this.nv.setTimeout(a, 0);
            }
            else {
                window.setTimeout(a, 0);
            }
        }
        n9(a) {
            this.kg(a);
        }
        nw() {
            let a = new ChartVisualData();
            let b = this.nc.e5();
            let c = this.ne.e5();
            a.axes.add1(b);
            a.axes.add1(c);
            for (let d = 0; d < this.series.count; d++) {
                let e = this.series._inner[d].fo();
                a.series.add1(e);
            }
            a.name = this.name;
            a.contentArea = RectData.b(this.m5);
            a.centralArea = RectData.b(this.m5);
            a.plotArea = RectData.b(this.m5);
            return a;
        }
        my(a, b, c) {
            return a;
        }
        od() {
        }
        get pe() {
            return this.o0;
        }
        set pe(a) {
            this.o0 = a;
        }
        on(a) {
            this.pe = a;
            this.om();
        }
        om() {
            if (this.np && !this.pe.isEmpty) {
                let a = this.getZoomFromGeographicRect(this.pe);
                this.pe = Rect.empty;
                this.km(a, false);
            }
        }
        get np() {
            return !this.m5.isEmpty && !this.mv.isEmpty;
        }
    }
    XamGeographicMap.$t = /*@__PURE__*/ markType(XamGeographicMap, 'XamGeographicMap', SeriesViewer.$, [IMapRenderDeferralHandler_$type]);
    XamGeographicMap.ni = 0;
    XamGeographicMap.oz = /*@__PURE__*/ new Rect(2, { $type: Point_$type, x: -180, y: -85.05112878 }, { $type: Point_$type, x: 180, y: 85.05112878 });
    XamGeographicMap.o2 = /*@__PURE__*/ new Rect(0, 0, 0, 1, 1);
    XamGeographicMap.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamGeographicMap, 'ji', ['ResizeBehavior:nj:oo', [MapResizeBehavior_$type, /*@__PURE__*/ enumGetBox(MapResizeBehavior_$type, XamGeographicMap.ni)], 'SuppressZoomResetOnWorldRectChange:nm:op', [0, false], 'UseWorldRectForZoomBounds:nn:oq', [0, false], 'WindowScale:nt:or', [1, NaN], 'WorldRect:pf:os', [Rect.$, XamGeographicMap.oz], 'Zoomable:no:ot', [0, true]]);
    return XamGeographicMap;
})();
/**
 * @hidden
 */
export let GeographicMapImagery = /*@__PURE__*/ (() => {
    class GeographicMapImagery extends Control {
        constructor(a) {
            super();
            this.ak = null;
            this.imageTilesReady = null;
            this.an = null;
            this.ap = null;
            this.propertyChanged = null;
            this.imagesChanged = null;
            this.cancellingImage = null;
            this.downloadingImage = null;
            this.ab = GeographicMapImagery.$;
            this.ap = a;
            this.aj = this.ai();
            this.a9(this.aj);
        }
        a9(a) {
        }
        ai() {
            return new GeographicMapImageryView(this);
        }
        get deferralHandler() {
            return this.ak;
        }
        set deferralHandler(a) {
            this.ak = a;
            if (this.ao != null) {
                this.ao.al = a;
            }
        }
        a3(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new ImageTilesReadyEventArgs());
            }
        }
        a7() {
            let a = this.ao;
            a.imageTilesReady = delegateCombine(a.imageTilesReady, runOn(this, this.a3));
            this.ao.al = this.deferralHandler;
            let b = this.ao;
            b.imagesChanged = delegateCombine(b.imagesChanged, runOn(this, this.a2));
            let c = this.ao;
            c.downloadingImage = delegateCombine(c.downloadingImage, runOn(this, this.a1));
            let d = this.ao;
            d.cancellingImage = delegateCombine(d.cancellingImage, runOn(this, this.a0));
            this.ao.bc = this.referer;
            this.ao.bg = this.userAgent;
        }
        a1(a, b) {
            if (this.downloadingImage != null) {
                this.downloadingImage(this, b);
            }
        }
        a0(a, b) {
            if (this.cancellingImage != null) {
                this.cancellingImage(this, b);
            }
        }
        be() {
            if (this.ao != null) {
                this.aj.e();
            }
        }
        a8(a, b, c) {
            switch (a) {
                case GeographicMapImagery.$$p[2]:
                    this.be();
                    break;
                case "GeographicMap":
                    this.aj.e();
                    break;
                case GeographicMapImagery.$$p[0]:
                    if (this.ao != null) {
                        this.ao.bc = this.referer;
                    }
                    break;
                case GeographicMapImagery.$$p[1]:
                    if (this.ao != null) {
                        this.ao.bg = this.userAgent;
                    }
                    break;
            }
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
        get geographicMap() {
            return this.c(GeographicMapImagery.geographicMapProperty);
        }
        set geographicMap(a) {
            this.h(GeographicMapImagery.geographicMapProperty, a);
        }
        static a6(a, b) {
            a.a5(b.oldValue, b.newValue);
        }
        a5(a, b) {
            this.a8("GeographicMap", a, b);
        }
        clearTileCache() {
            if (this.ao != null) {
                this.ao.bp(0, 0, 0, 0);
            }
        }
        get ao() {
            return this.an;
        }
        set ao(a) {
            this.an = a;
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs("MultiScaleImage"));
            }
        }
        bk(a) {
            if (this.geographicMap == null || a.width < 1 || a.height < 1) {
                return a;
            }
            let b = new Rect(0, 0, 0, a.width, a.height);
            let c = this.geographicMap.o8(b);
            let d = XamGeographicMap.oz;
            let e = this.geographicMap.o3;
            let f = Math.min(this.windowRect.height, this.windowRect.width);
            let g = e.width / d.width;
            this.ao.a3 = (b.width / c.width) * f * g;
            let h = this.geographicMap.nc;
            let i = this.geographicMap.ne;
            let j = new ScalerParams(1, this.windowRect, b, h.ca);
            j.c = c;
            let k = new ScalerParams(1, this.windowRect, b, i.ca);
            k.c = c;
            let l = h.dy(d.left, j);
            let m = i.dy(d.bottom, k);
            let n = (-l / b.width) * this.ao.a3;
            let o = (-m / b.height) * this.ao.a3 * (b.height / b.width);
            this.ao.ci = { $type: Point_$type, x: n, y: o };
            return a;
        }
        bb(a) {
            this.aj.f(a);
        }
        bd(a) {
            this.aj.h(a);
        }
        bc(a) {
            this.aj.g(a);
        }
        a2(a, b) {
            if (this.imagesChanged != null) {
                this.imagesChanged(this, new ImagesChangedEventArgs());
            }
        }
        a4() {
            this.aj.e();
        }
        ba(a) {
            this.aj.i(a);
        }
        v() {
            super.v();
            this.ap.m = this._opacity;
        }
    }
    GeographicMapImagery.$t = /*@__PURE__*/ markType(GeographicMapImagery, 'GeographicMapImagery', Control.$, [INotifyPropertyChanged_$type]);
    GeographicMapImagery.geographicMapProperty = /*@__PURE__*/ DependencyProperty.i("GeographicMap", XamGeographicMap.$, GeographicMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, GeographicMapImagery.a6));
    GeographicMapImagery.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicMapImagery, 'a8', ['Referer', [2, null], 'UserAgent', [2, null], 'WindowRect', [Rect.$, Rect.empty]]);
    return GeographicMapImagery;
})();
/**
 * @hidden
 */
export let GeographicMapImageryView = /*@__PURE__*/ (() => {
    class GeographicMapImageryView extends Base {
        constructor(a) {
            super();
            this.a = null;
            this.j = null;
            this.d = null;
            this.b = 1;
            this.j = Rect.empty;
            this.a = a;
            this.a.ao = new XamMultiScaleImage();
            this.a.ao.ao = this.a.ap;
            this.a.a7();
        }
        e() {
            if (this.j.isEmpty) {
                return;
            }
            this.a.bk(new Size(1, this.j.width, this.j.height));
        }
        f(a) {
            this.a.ao.by(a);
        }
        g(a) {
            this.d = a;
            this.a.ao.bz(a);
        }
        h(a) {
            this.j = a;
            this.a.ao.b0(a);
            this.a.a4();
        }
        get c() {
            return this.b;
        }
        i(a) {
            this.b = a;
            this.a.ao.bw(a);
        }
    }
    GeographicMapImageryView.$t = /*@__PURE__*/ markType(GeographicMapImageryView, 'GeographicMapImageryView');
    return GeographicMapImageryView;
})();
/**
 * @hidden
 */
export let GeographicXYTriangulatingSeriesView = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeriesView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            super.bv();
            let a = this.b0.l3;
            a.mz = this.b0.mf;
            a.m3 = this.b0.md;
            a.trianglesSource = this.b0.mc;
            a.mr = this.b0.mi;
            a.mt = this.b0.mk;
            a.mv = this.b0.mm;
        }
        b3() {
            let a = this.b0.l3;
            if (this.b0.bs == null) {
                a.l1 = null;
                a.l2 = null;
                return;
            }
            a.l1 = this.b0.bs.nc;
            a.l2 = this.b0.bs.ne;
        }
        b2() {
            this.b0.l3.mz = this.b0.mf;
        }
        b1() {
            this.b0.l3.m3 = this.b0.md;
        }
        b4() {
            this.b0.l3.trianglesSource = this.b0.mc;
        }
        b5() {
            this.b0.l3.mr = this.b0.mi;
        }
        b6() {
            this.b0.l3.mt = this.b0.mk;
        }
        b7() {
            this.b0.l3.mv = this.b0.mm;
        }
    }
    GeographicXYTriangulatingSeriesView.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeriesView, 'GeographicXYTriangulatingSeriesView', HostSeriesView.$);
    return GeographicXYTriangulatingSeriesView;
})();
/**
 * @hidden
 */
export let GeographicScatterAreaSeriesView = /*@__PURE__*/ (() => {
    class GeographicScatterAreaSeriesView extends GeographicXYTriangulatingSeriesView {
        constructor(a) {
            super(a);
            this.b8 = null;
            this.b8 = a;
        }
        bv() {
            super.bv();
            if (this.b8.mw != null) {
                this.b8.mw.nu = this.b8.mz;
                this.b8.mw.nm = this.b8.mv;
            }
        }
        b9() {
            if (this.b8.mw != null) {
                this.b8.mw.nu = this.b8.mz;
            }
        }
        ca() {
            if (this.b8.mw != null) {
                this.b8.mw.nm = this.b8.mv;
            }
        }
    }
    GeographicScatterAreaSeriesView.$t = /*@__PURE__*/ markType(GeographicScatterAreaSeriesView, 'GeographicScatterAreaSeriesView', GeographicXYTriangulatingSeriesView.$);
    return GeographicScatterAreaSeriesView;
})();
/**
 * @hidden
 */
export let XamGeographicMapView = /*@__PURE__*/ (() => {
    class XamGeographicMapView extends SeriesViewerView {
        constructor(a) {
            super(a);
            this.fe = null;
            this.fu = null;
            this.fo = null;
            this.fn = null;
            this.ff = null;
            this.fg = NaN;
            this.fu = Rect.empty;
            this.fe = a;
            this.fe.l1 = 2;
            this.fe.ex = 5E-06;
        }
        k(a) {
            return 2;
        }
        bi(a) {
            this.i.bv(a);
            this.fe.n9(a);
            this.ee();
        }
        get_an() {
            return true;
        }
        dx() {
            let a;
            let b;
            let c;
            let d;
            let e;
            let f = this.i.a7(a, b, c, d, e);
            a = f.p0;
            b = f.p1;
            c = f.p2;
            d = f.p3;
            e = f.p4;
            this.fo = c;
            this.ff = d;
            this.fn = e;
        }
        fq(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(0,0,0,1)";
                return $ret;
            })());
        }
        fr(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "white";
                return $ret;
            })());
        }
        fp(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(50,50,50,.5)";
                return $ret;
            })());
        }
        fs(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "white";
                return $ret;
            })());
        }
        dm(a) {
            super.dm(a);
            if (this.fe.backgroundContent != null) {
                let b = this.fe.backgroundContent;
                b.bc(this.i.ae);
                b.bb(a);
            }
        }
        dn(a) {
            super.dn(a);
            this.fu = a;
            if (this.fe.backgroundContent != null) {
                let b = this.fe.backgroundContent;
                b.bd(this.fu);
            }
        }
        ft() {
            return new Rect(0, 0, 0, this.fu.width, this.fu.height);
        }
        fj() {
            if (this.fe.backgroundContent != null) {
                let a = this.fe.backgroundContent;
                a.a4();
            }
        }
        fi(a) {
            if (this.fe.nh != null) {
                this.fe.nh.windowRect = a;
            }
        }
        fl(a, b) {
            if (this.fe.nh != null) {
                this.fe.nh.windowRect = this.fe.mr;
            }
            if (a != null) {
                let c = a.ao;
                if (c != null) {
                    this.fe.ah.e.remove(c.ag);
                }
                a.bb(null);
                a.bc(null);
            }
            if (b != null) {
                let d = b.ao;
                if (d != null) {
                    this.fe.ah.e.add(d.ag);
                }
                if (!this.fu.isEmpty) {
                    this.dn(this.fu);
                }
                if (this.u != null) {
                    this.dm(this.u);
                }
            }
            if (b == null) {
                this.fk(this.u);
            }
        }
        fk(a) {
            let b = this.fe.ea;
            if (b != 1) {
                a.z();
                a.aa(b, b);
            }
            a.k(this.fu.left, this.fu.top, this.fu.width, this.fu.height);
            if (b != 1) {
                a.y();
            }
        }
        du() {
            this.e6.ac = 1;
            this.e7.ac = 1;
            this.e6._stroke = this.fo;
            this.e7._stroke = this.fo;
            super.du();
        }
        fm(a) {
            this.fg = a;
            if (this.fe.backgroundContent != null) {
                this.fe.backgroundContent.ba(a);
            }
        }
        get fh() {
            return this.fg;
        }
        set fh(a) {
            this.fg = a;
        }
    }
    XamGeographicMapView.$t = /*@__PURE__*/ markType(XamGeographicMapView, 'XamGeographicMapView', SeriesViewerView.$);
    return XamGeographicMapView;
})();
/**
 * @hidden
 */
export let OpenStreetMapImagery = /*@__PURE__*/ (() => {
    class OpenStreetMapImagery extends GeographicMapImagery {
        constructor() {
            super(new OpenStreetMapTileSource());
        }
        get tilePath() {
            return this.c(OpenStreetMapImagery.tilePathProperty);
        }
        set tilePath(a) {
            this.h(OpenStreetMapImagery.tilePathProperty, a);
        }
        static bo(a, b) {
            a.bn("TilePath", b.oldValue, b.newValue);
        }
        bn(a, b, c) {
            switch (a) {
                case "TilePath":
                    this.ap.setTilePathUrl(c == null ? null : c);
                    this.aj.e();
                    break;
            }
            super.a8(a, b, c);
        }
    }
    OpenStreetMapImagery.$t = /*@__PURE__*/ markType(OpenStreetMapImagery, 'OpenStreetMapImagery', GeographicMapImagery.$);
    OpenStreetMapImagery.tilePathProperty = /*@__PURE__*/ DependencyProperty.i("TilePath", String_$type, OpenStreetMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, OpenStreetMapImagery.bo));
    return OpenStreetMapImagery;
})();
/**
 * @hidden
 */
export let GeographicXYTriangulatingSeries = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeries extends GeographicMapSeriesHost {
        bf() {
            return new GeographicXYTriangulatingSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mb = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.mb.b3();
                    break;
                case GeographicXYTriangulatingSeries.$$p[1]:
                    this.mb.b2();
                    break;
                case GeographicXYTriangulatingSeries.$$p[0]:
                    this.mb.b1();
                    break;
                case GeographicXYTriangulatingSeries.$$p[2]:
                    this.mb.b4();
                    break;
                case GeographicXYTriangulatingSeries.$$p[3]:
                    this.mb.b5();
                    break;
                case GeographicXYTriangulatingSeries.$$p[4]:
                    this.mb.b6();
                    break;
                case GeographicXYTriangulatingSeries.$$p[5]:
                    this.mb.b7();
                    break;
            }
        }
    }
    GeographicXYTriangulatingSeries.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeries, 'GeographicXYTriangulatingSeries', GeographicMapSeriesHost.$);
    GeographicXYTriangulatingSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicXYTriangulatingSeries, 'raisePropertyChanged', ['LatitudeMemberPath:md:mo', [2, "pointY"], 'LongitudeMemberPath:mf:mp', [2, "pointX"], 'TrianglesSource:mc:mq', [IEnumerable_$type, null], 'TriangleVertexMemberPath1:mi:mr', [2, "v1"], 'TriangleVertexMemberPath2:mk:ms', [2, "v2"], 'TriangleVertexMemberPath3:mm:mt', [2, "v3"]]);
    return GeographicXYTriangulatingSeries;
})();
/**
 * @hidden
 */
export let GeographicScatterAreaSeries = /*@__PURE__*/ (() => {
    class GeographicScatterAreaSeries extends GeographicXYTriangulatingSeries {
        constructor() {
            super();
            this.mu = null;
            this.triangulationStatusChanged = null;
            this.ab = GeographicScatterAreaSeries.$;
        }
        get mv() {
            return this.mu;
        }
        set mv(a) {
            let b = this.mu != a;
            if (b) {
                let c = this.mu;
                this.mu = a;
                this.raisePropertyChanged("ColorScale", c, this.mu);
                if (this.mw != null) {
                    this.mw.nm = a;
                }
            }
        }
        l2() {
            this.mw = new ScatterAreaSeries();
            let a = this.mw;
            a.triangulationStatusChanged = delegateCombine(a.triangulationStatusChanged, runOn(this, this.m2));
            return this.mw;
        }
        m2(a, b) {
            if (this.triangulationStatusChanged != null) {
                this.triangulationStatusChanged(this, b);
            }
        }
        bf() {
            return new GeographicScatterAreaSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.my = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case GeographicScatterAreaSeries.$$p[0]:
                    this.my.b9();
                    break;
                case "ColorScale":
                    this.my.ca();
                    break;
            }
        }
        get_dq() {
            return true;
        }
        set_dq(a) {
            super.set_dq(a);
        }
    }
    GeographicScatterAreaSeries.$t = /*@__PURE__*/ markType(GeographicScatterAreaSeries, 'GeographicScatterAreaSeries', GeographicXYTriangulatingSeries.$);
    GeographicScatterAreaSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicScatterAreaSeries, 'raisePropertyChanged', ['ColorMemberPath:mz:m3', [2, "value"]]);
    return GeographicScatterAreaSeries;
})();
//# sourceMappingURL=XamGeographicMap_combined.js.map
