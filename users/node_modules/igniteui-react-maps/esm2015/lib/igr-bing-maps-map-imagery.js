import { IgrSubDomainsCollection } from "./igr-sub-domains-collection";
import { BingMapsImageryStyle_$type } from "./BingMapsImageryStyle";
import { IgrGeographicMapImagery } from "./igr-geographic-map-imagery";
import { BingMapsMapImagery as BingMapsMapImagery_internal } from "./BingMapsMapImagery";
import { ensureBool, ensureEnum } from "igniteui-react-core";
import { SubDomainsCollection as SubDomainsCollection_internal } from "./SubDomainsCollection";
import { String_$type } from "igniteui-react-core";
import { SyncableObservableCollection$1 } from "igniteui-react-core";
/**
 * UI element class used to display BingMapsMap imagery in the IgxGeographicMap.Component
*/
export class IgrBingMapsMapImagery extends IgrGeographicMapImagery {
    constructor() {
        super();
        this._subDomains = null;
        this._actualSubDomains = null;
    }
    createImplementation() {
        return new BingMapsMapImagery_internal();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets a status whether the Bing Maps service is initialized.
    */
    get isInitialized() {
        return this.i.isInitialized;
    }
    set isInitialized(v) {
        this.i.isInitialized = ensureBool(v);
    }
    /**
     * Gets or sets whether the Bing Maps service should be auto-initialized upon valid property values.
    */
    get isDeferredLoad() {
        return this.i.isDeferredLoad;
    }
    set isDeferredLoad(v) {
        this.i.isDeferredLoad = ensureBool(v);
    }
    /**
     * Gets or sets the map tile image uri.
    */
    get tilePath() {
        return this.i.tilePath;
    }
    set tilePath(v) {
        this.i.tilePath = v;
    }
    /**
     * Gets or sets the actual map tile image uri.
    */
    get actualTilePath() {
        return this.i.actualTilePath;
    }
    set actualTilePath(v) {
        this.i.actualTilePath = v;
    }
    /**
     * Gets or sets the collection of image uri subdomains.
    */
    get subDomains() {
        if (this._subDomains === null) {
            let coll = new IgrSubDomainsCollection();
            let innerColl = this.i.subDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection_internal(0);
            }
            this._subDomains = coll._fromInner(innerColl);
            this.i.subDomains = innerColl;
        }
        return this._subDomains;
    }
    set subDomains(v) {
        if (this._subDomains !== null) {
            this._subDomains._setSyncTarget(null);
            this._subDomains = null;
        }
        let coll = new IgrSubDomainsCollection();
        this._subDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.subDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._subDomains._setSyncTarget(syncColl);
        this.i.subDomains = innerColl;
    }
    /**
     * Gets or sets the actual collection of image uri subdomains.
    */
    get actualSubDomains() {
        if (this._actualSubDomains === null) {
            let coll = new IgrSubDomainsCollection();
            let innerColl = this.i.actualSubDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection_internal(0);
            }
            this._actualSubDomains = coll._fromInner(innerColl);
            this.i.actualSubDomains = innerColl;
        }
        return this._actualSubDomains;
    }
    set actualSubDomains(v) {
        if (this._actualSubDomains !== null) {
            this._actualSubDomains._setSyncTarget(null);
            this._actualSubDomains = null;
        }
        let coll = new IgrSubDomainsCollection();
        this._actualSubDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.actualSubDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._actualSubDomains._setSyncTarget(syncColl);
        this.i.actualSubDomains = innerColl;
    }
    /**
     * Gets or sets the Bing Imagery Rest Uri.
    */
    get bingImageryRestUri() {
        return this.i.bingImageryRestUri;
    }
    set bingImageryRestUri(v) {
        this.i.bingImageryRestUri = v;
    }
    /**
     * Gets or sets the Actual Bing Imagery Rest Uri.
    */
    get actualBingImageryRestUri() {
        return this.i.actualBingImageryRestUri;
    }
    set actualBingImageryRestUri(v) {
        this.i.actualBingImageryRestUri = v;
    }
    /**
     * Gets or sets the culture name for this tile source.
    */
    get cultureName() {
        return this.i.cultureName;
    }
    set cultureName(v) {
        this.i.cultureName = v;
    }
    /**
     * Gets or sets an API key required by the Bing Maps imagery service.
     * This key must be obtained from the http://www.bingmapsportal.com website.
    */
    get apiKey() {
        return this.i.apiKey;
    }
    set apiKey(v) {
        this.i.apiKey = v;
    }
    /**
     * Gets or sets a map style of the Bing Maps imagery tiles.  For example: Aerial, AerialWithLabels, or Road map style.
    */
    get imageryStyle() {
        return this.i.imageryStyle;
    }
    set imageryStyle(v) {
        this.i.imageryStyle = ensureEnum(BingMapsImageryStyle_$type, v);
    }
    /**
     * Will Connect to the Bing Rest API and retrieve the required TilePath and Subdomains from the service.  This requires a valid API key to already be set.
    
    */
    requestMapSettings() {
        this.i.requestMapSettings();
    }
}
//# sourceMappingURL=igr-bing-maps-map-imagery.js.map
