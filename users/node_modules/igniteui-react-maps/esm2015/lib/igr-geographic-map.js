/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { IgrSeriesViewer } from "igniteui-react-charts";
import { ReactRenderer, ReactWrapper } from "igniteui-react-core";
import { TypeRegistrar, delegateCombine, delegateRemove } from "igniteui-react-core";
import { XamGeographicMap } from './XamGeographicMap';
import { CollectionAdapter, toPoint, fromPoint, toRect, fromRect, ensureBool, ensureEnum, NamePatcher } from "igniteui-react-core";
import { DataChartStylingDefaults } from "igniteui-react-charts";
import { IgrDataContext } from "igniteui-react-core";
import { IgrSeriesCollection } from "igniteui-react-charts";
import { NotifyCollectionChangedAction } from "igniteui-react-core";
import { IgrNumericXAxis } from "igniteui-react-charts";
import { IgrNumericYAxis } from "igniteui-react-charts";
import { ContentChildrenManager } from "igniteui-react-core";
import { IgrImageTilesReadyEventArgs } from './igr-image-tiles-ready-event-args';
import { MapResizeBehavior_$type } from './MapResizeBehavior';
/**
 * Represents the Infragistics IgxGeographicMapComponent control.
*/
export class IgrGeographicMap extends IgrSeriesViewer {
    constructor(props) {
        super(props);
        this.contentSeries = [];
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing React to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        this.actualSeries = [];
        this._series = null;
        this._initialized = false;
        this._seriesAdapter = null;
        this._defaultTooltips = null;
        this._uniqueTooltipId = 0;
        this._imageTilesReady = null;
        this._imageTilesReady_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.key || ch.props.name, (ch) => ch.key || ch.props.name, () => this._updateContentChildren());
        if (document) {
            this._container = document.createElement("div");
            this._container.style.display = "block";
            this._container.style.width = "100%";
            this._container.style.height = "100%";
        }
        var root;
        root = this._container;
        var ren = new ReactRenderer(root, document, true, DataChartStylingDefaults);
        this._wrapper = ren;
        var chart = this.i;
        this._chart = chart;
        this._seriesAdapter = new CollectionAdapter(this.contentSeries, this.i.series, this.actualSeries, (c) => c.i, (i) => {
            i.owner = this;
            i._provideRenderer(this._dataSource);
            i.provideData(this._dataSource);
            if (this._container && this._container.parentElement) {
                i._styling(this._container, this, this);
            }
            this._ensureDefaultTooltip(i);
            this._ensureTooltipCreated(i);
        }, (i) => { i._provideRenderer(null); i.provideData(null); });
        chart.provideContainer(ren);
        ren.addSizeWatcher(() => {
            this._chart.notifyContainerResized();
        });
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this._chart.notifyContainerResized();
        }
    }
    get height() {
        return this._height;
    }
    /**
     * Gets or sets the legend used for the current chart.
    */
    get legend() {
        if (this.i.legend != null)
            return this.i.legend.externalObject;
    }
    set legend(v) {
        if (v != undefined && v != null)
            this.i.legend = v.i;
    }
    _updateContentChildren() {
        this.contentSeries.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            this.contentSeries.push(contentChildrenActual[i]);
        }
        if (this._seriesAdapter !== null) {
            this._seriesAdapter.notifyContentChanged();
        }
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            //children = React.Children.toArray(this.props.children);
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = React.createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = ReactDOM.createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        let div = React.createElement("div", {
            className: "ig-geographic-map igr-geographic-map",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    componentDidMount() {
        super.componentDidMount();
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container);
        this._chart.notifyContainerResized();
        this.initializeContent();
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this._chart.notifyContainerResized();
        }
    }
    get width() {
        return this._width;
    }
    /**
     * A collection or manually added series for the chart.
    */
    get series() {
        if (this._series === null) {
            let coll = new IgrSeriesCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._seriesAdapter.addManualItem(e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._seriesAdapter.clearManualItems();
                        break;
                }
            });
            this._series = coll;
        }
        return this._series;
    }
    componentWillUnmount() {
        this._chart.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamGeographicMap();
    }
    set dataSource(value) {
        this._dataSource = value;
        this.bindData();
    }
    get dataSource() {
        return this._dataSource;
    }
    bindData() {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i].provideData(this._dataSource);
            }
        }
    }
    initializeContent() {
        if (TypeRegistrar.isRegistered("IgrDataChartDefaultTooltips")) {
            let d = TypeRegistrar.create("IgrDataChartDefaultTooltips");
            this._defaultTooltips = d;
            this._onDefaultTooltipsReady(d);
            //this._container.appendChild(cr.location.nativeElement);
        }
        this._styling(this._container, this);
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i]._styling(this._container, this, this);
            }
        }
        this.i.notifyContainerResized();
    }
    _ensureTooltipCreated(series) {
        series._ensureTooltipCreated(() => this.createTooltip(), (ele) => {
            let wrapper = new ReactWrapper(ele, this._wrapper);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
            return wrapper;
        });
    }
    _ensureDefaultTooltip(series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](series);
    }
    _onDefaultTooltipsReady(cr) {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                if (currSeries[i].showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries[i]);
                }
            }
        }
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    /**
     * An imagery to display behind all series, inside the viewport of the IgrGeographicMapComponent control.
    */
    get backgroundContent() {
        if (this.i.backgroundContent != null) {
            return this.i.backgroundContent.externalObject;
        }
        else {
            return null;
        }
    }
    set backgroundContent(v) {
        if (v != undefined && v != null) {
            this.i.backgroundContent = v.i;
        }
        else {
            this.i.backgroundContent = null;
        }
    }
    /**
                             * @hidden
                             */
    get i() {
        return this._implementation;
    }
    /**
 * Gets or sets zoomability of the current control
*/
    get zoomable() {
        return this.i.no;
    }
    set zoomable(v) {
        this.i.no = ensureBool(v);
    }
    /**
     * Gets or sets the behavior to use during resize.
    */
    get resizeBehavior() {
        return this.i.nj;
    }
    set resizeBehavior(v) {
        this.i.nj = ensureEnum(MapResizeBehavior_$type, v);
    }
    /**
     * Gets or sets whether to use the uncoerced world rect to constrain the zoom bounds.
    */
    get useWorldRectForZoomBounds() {
        return this.i.nn;
    }
    set useWorldRectForZoomBounds(v) {
        this.i.nn = ensureBool(v);
    }
    /**
     * Gets or sets whether skip resetting the zoom when the world rect changes.
    */
    get suppressZoomResetOnWorldRectChange() {
        return this.i.nm;
    }
    set suppressZoomResetOnWorldRectChange(v) {
        this.i.nm = ensureBool(v);
    }
    /**
     * Gets or sets the world bounding rectangle.
    */
    get worldRect() {
        return fromRect(this.i.pf);
    }
    set worldRect(v) {
        this.i.pf = toRect(v);
    }
    /**
     * Gets the actual value of the WorldRect.
    */
    get actualWorldRect() {
        return fromRect(this.i.o3);
    }
    set actualWorldRect(v) {
        this.i.o3 = toRect(v);
    }
    /**
     * The X-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get xAxis() {
        if (this.i.nc == null) {
            return null;
        }
        if (!this.i.nc.externalObject) {
            let e = IgrNumericXAxis._createFromInternal(this.i.nc);
            if (e) {
                e._implementation = this.i.nc;
            }
            this.i.nc.externalObject = e;
        }
        return this.i.nc.externalObject;
    }
    set xAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.nc = null : this.i.nc = v.i;
    }
    /**
     * The Y-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get yAxis() {
        if (this.i.ne == null) {
            return null;
        }
        if (!this.i.ne.externalObject) {
            let e = IgrNumericYAxis._createFromInternal(this.i.ne);
            if (e) {
                e._implementation = this.i.ne;
            }
            this.i.ne.externalObject = e;
        }
        return this.i.ne.externalObject;
    }
    set yAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.ne = null : this.i.ne = v.i;
    }
    /**
     * Indicates if this SeriesViewer is a map.
    */
    get isMap() {
        return this.i.cx;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the WindowRect property.
    */
    get windowScale() {
        return this.i.nt;
    }
    set windowScale(v) {
        this.i.nt = +v;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the ActualWindowRect property.
    */
    get actualWindowScale() {
        return this.i.ns;
    }
    set actualWindowScale(v) {
        this.i.ns = +v;
    }
    /**
     * Gets whether or not the control is ready for zooming
    */
    get zoomIsReady() {
        return this.i.np;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.backgroundContent && this.backgroundContent.name && this.backgroundContent.name == name) {
            return this.backgroundContent;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.xAxis && this.xAxis._styling) {
            this.xAxis._styling(container, component, this);
        }
        if (this.yAxis && this.yAxis._styling) {
            this.yAxis._styling(container, component, this);
        }
        this._inStyling = false;
    }
    getCurrentActualWorldRect() {
        let iv = this.i.o7();
        return fromRect(iv);
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomRectFromGeoRect(geographic) {
        let iv = this.i.getZoomRectFromGeoRect(toRect(geographic));
        return fromRect(iv);
    }
    updateZoomWindow(zoomWindow) {
        this.i.ol(toRect(zoomWindow));
    }
    updateWorldRect(worldRect) {
        this.i.ok(toRect(worldRect));
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomFromGeographicRect(geographic) {
        let iv = this.i.getZoomFromGeographicRect(toRect(geographic));
        return fromRect(iv);
    }
    convertGeographicToZoom(geographic, extraPixelPadding) {
        let iv = this.i.o4(toRect(geographic), extraPixelPadding);
        return fromRect(iv);
    }
    getZoomFromGeographicPoints(northWest, southEast) {
        let iv = this.i.getZoomFromGeographicPoints(toPoint(northWest), toPoint(southEast));
        return fromRect(iv);
    }
    /**
     * Given a WindowRect and the current plot area, get the geographic region represented by that WindowRect.
    
    * @param windowRect  * The zoom area.
    */
    getGeographicFromZoom(windowRect) {
        let iv = this.i.o9(toRect(windowRect));
        return fromRect(iv);
    }
    /**
     * Convert a pixel-based coordinate to a geographic coordinate.
    
    * @param pixelCoordinate  * A pixel-based coordinate
    */
    getGeographicPoint(pixelCoordinate) {
        let iv = this.i.ov(toPoint(pixelCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getPixelPoint(geographicCoordinate) {
        let iv = this.i.ow(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getWindowPoint(geographicCoordinate) {
        let iv = this.i.ox(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Removes all cached tile images from the map imagery assigned to the map's background content.
    
    */
    clearTileCache() {
        this.i.n8();
    }
    /**
     * Notifies the chart that the CSS styles in effect have been updated.
    
    */
    styleUpdated() {
        this.i.og();
    }
    /**
     * Gets actual window scale for horizontal dimension of the control
    
    */
    getActualWindowScaleHorizontal() {
        let iv = this.i.eg();
        return (iv);
    }
    /**
     * Gets actual window scale for vertical dimension of the control
    
    */
    getActualWindowScaleVertical() {
        let iv = this.i.eh();
        return (iv);
    }
    /**
     * Calls for a deferred refresh to the GeographicMap's background.
    
    */
    deferredRefresh() {
        this.i.deferredRefresh();
    }
    /**
     * Returns the chart visuals expressed as a ChartVisualData object.
    
    */
    exportVisualData() {
        let iv = this.i.nw();
        return (iv);
    }
    /**
     * Zoom in to the geographic region specified, when possible (may need to wait for map to be initialized).
    
    * @param geographic  * The geographic region to zoom to.
    */
    zoomToGeographic(geographic) {
        this.i.on(toRect(geographic));
    }
    /**
     * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
    */
    get imageTilesReady() {
        return this._imageTilesReady;
    }
    set imageTilesReady(ev) {
        if (this._imageTilesReady_wrapped !== null) {
            this.i.imageTilesReady = delegateRemove(this.i.imageTilesReady, this._imageTilesReady_wrapped);
            this._imageTilesReady_wrapped = null;
            this._imageTilesReady = null;
        }
        this._imageTilesReady = ev;
        this._imageTilesReady_wrapped = (o, e) => {
            let outerArgs = new IgrImageTilesReadyEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeImageTilesReady) {
                this.beforeImageTilesReady(this, outerArgs);
            }
            if (this._imageTilesReady) {
                this._imageTilesReady(this, outerArgs);
            }
        };
        this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, this._imageTilesReady_wrapped);
    }
}
//# sourceMappingURL=igr-geographic-map.js.map
