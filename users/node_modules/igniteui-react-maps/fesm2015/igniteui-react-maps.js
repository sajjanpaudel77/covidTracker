import { createElement } from 'react';
import { createPortal } from 'react-dom';
import { VerticalLinearScaler, HorizontalLinearScaler, Series, SeriesViewer, SeriesView, NumericXAxis, NumericYAxis, ScalerParams, ChartVisualData, SeriesViewerView, ScatterAreaSeries, IgrSeriesViewer, DataChartStylingDefaults, IgrSeriesCollection, IgrNumericXAxis, IgrNumericYAxis, IgrSeries, ScatterPolygonSeries, CollisionAvoidanceType_$type, MarkerType_$type, StyleSelector, IgrStyleShapeEventArgs, IgrScatterPolygonSeriesModule, ScatterPolylineSeries, IgrScatterPolylineSeriesModule, ShapeSeriesBase, ShapeSeriesViewBase, IgrShapeSeriesBase, BubbleSeries, BrushScale, SizeScale, IgrSizeScale, IgrBrushScale, IgrBubbleSeriesModule, ScatterSeries, IgrScatterSeriesModule, IgrColorScale, IgrScatterAreaSeriesModule, HighDensityScatterSeries, IgrProgressiveLoadStatusEventArgs, IgrHighDensityScatterSeriesModule, ScatterContourSeries, ValueBrushScale, ContourValueResolver, IgrValueBrushScale, IgrContourValueResolver, IgrScatterContourSeriesModule, IgrSizeScaleModule, IgrValueBrushScaleModule, IgrCustomPaletteColorScaleModule } from 'igniteui-react-charts';
import { markEnum, Rect, markType, EventArgs, TypeRegistrar, PlatformConstants, typeCast, delegateRemove, runOn, delegateCombine, isNaN_, DependencyProperty, Number_$type, PropertyMetadata, Point_$type, fromEnum, MathUtil, intDivide, truncate, ItfConverter, RectData, IMapRenderDeferralHandler_$type, markDep, enumGetBox, Control, PropertyChangedEventArgs, INotifyPropertyChanged_$type, Base, XamMultiScaleImage, Size, Brush, OpenStreetMapTileSource, String_$type, IEnumerable_$type, NamePatcher, ContentChildrenManager, ReactRenderer, CollectionAdapter, NotifyCollectionChangedAction, ReactWrapper, IgrDataContext, ensureBool, ensureEnum, fromRect, toRect, toPoint, fromPoint, IgCollection, SyncableObservableCollection$2, IgrCancellingMultiScaleImageEventArgs, IgrDownloadingMultiScaleImageEventArgs, ObservableCollection$1, BingMapsTileSource, stringIsNullOrEmpty, Uri, HttpRequestUtil, List$1, stringEmpty, SyncableObservableCollection$1, IgrGetTileImageUriArgs, ArcGISOnlineTileSource, stringFormat1, stringRemove, stringFormat, Boolean_$type, IgrShapeDataSource, Style, DataTemplate, DeviceUtils, brushToString, stringToBrush, TileGeneratorTileSource, stringReplace, ITileGenerator_$type, GeometryGroup, RenderingContext, CanvasViewRenderer, IgrTriangulationDataSource, IgrTriangulationStatusEventArgs, Color, colorToString, stringToColor, IgrHeatTileGeneratorModule, IgrShapeDataSourceModule } from 'igniteui-react-core';

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Indicates the desired behavior for the map on resizing.
 */
var MapResizeBehavior = /*@__PURE__*/ (function (MapResizeBehavior) {
    /**
     * Indicates that the map should decide the desired resize mode automatically.
     */
    MapResizeBehavior[MapResizeBehavior["Auto"] = 0] = "Auto";
    /**
     * Map will attempt to keep the top left position static during resize.
     */
    MapResizeBehavior[MapResizeBehavior["MaintainTopLeftPosition"] = 1] = "MaintainTopLeftPosition";
    /**
     * Map will attempt to keep the center position static during resize.
     */
    MapResizeBehavior[MapResizeBehavior["MaintainCenterPosition"] = 2] = "MaintainCenterPosition";
    return MapResizeBehavior;
})({});
/**
 * @hidden
 */
let MapResizeBehavior_$type = /*@__PURE__*/ markEnum('MapResizeBehavior', 'Auto,0|MaintainTopLeftPosition,1|MaintainCenterPosition,2');

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SphericalMercatorVerticalScaler = /*@__PURE__*/ (() => {
    class SphericalMercatorVerticalScaler extends VerticalLinearScaler {
        constructor() {
            super();
            this.au = null;
            this.ai = 0;
            this.aj = 0;
            this.au = new Rect(0, 0, 0, 1, 1);
        }
        q(a, b) {
            if (!b.c.isEmpty) {
                let c = a * b.e.height + b.e.top * b.d.height;
                let d = this.getMercatorUnscaledValue(c, this.au, b.c, b.a);
                return d;
            }
            else {
                return this.getMercatorUnscaledValue(a, b.e, b.d, b.a);
            }
        }
        p(a, b) {
            if (!b.c.isEmpty) {
                let c = this.getMercatorScaledValue1(a, this.au, b.c, b.a);
                c = (c - (b.e.top * b.d.height)) / b.e.height;
                return c;
            }
            else {
                return this.getMercatorScaledValue1(a, b.e, b.d, b.a);
            }
        }
        af(values_) {
            let a = (Array.isArray(values_) ? values_ : null);
            return a;
            return null;
        }
        v(a, b, c, d) {
            let e;
            let f = d.e;
            let g = d.d;
            let h = d.c;
            let i = d.a;
            let j = !h.isEmpty;
            let k = this.m;
            let l = this.o;
            let m = h.top;
            let n = h.height;
            let o = f.top;
            let p = f.height;
            let q = g.top;
            let r = g.height;
            let s = this.au.top;
            let t = this.au.height;
            let u = this.af(a);
            let v = 0.017453292519943295;
            let w;
            let x;
            let y;
            let z;
            let aa;
            let ab = false;
            if (u != null) {
                ab = true;
            }
            for (let ac = b; ac < c; ac++) {
                if (ab) {
                    e = u[ac];
                }
                else {
                    e = a.item(ac);
                }
                if (j) {
                    if (e < SphericalMercatorVerticalScaler.ah) {
                        e = SphericalMercatorVerticalScaler.ah;
                    }
                    if (e > SphericalMercatorVerticalScaler.ag) {
                        e = SphericalMercatorVerticalScaler.ag;
                    }
                    w = e * (v);
                    x = Math.sin(w);
                    y = 0.5 * Math.log((1 + x) / (1 - x));
                    z = (this.ai - y) * n / this.aj;
                    z = m + z;
                    aa = (z - s * n) / t;
                    z = (aa - (o * r)) / p;
                    if (ab) {
                        u[ac] = z;
                    }
                    else {
                        a.item(ac, z);
                    }
                }
                else {
                    if (e < SphericalMercatorVerticalScaler.ah) {
                        e = SphericalMercatorVerticalScaler.ah;
                    }
                    if (e > SphericalMercatorVerticalScaler.ag) {
                        e = SphericalMercatorVerticalScaler.ag;
                    }
                    w = e * (v);
                    x = Math.sin(w);
                    y = 0.5 * Math.log((1 + x) / (1 - x));
                    z = (this.ai - y) * r / this.aj;
                    z = q + z;
                    z = (z - o * r) / p;
                    if (ab) {
                        u[ac] = z;
                    }
                    else {
                        a.item(ac, z);
                    }
                }
            }
        }
        t(a, b, c, d, e) {
            d = this.ak(a.kj);
            e = this.ak(a.ki);
            return {
                p3: d,
                p4: e
            };
        }
        w(a, b, c) {
            super.w(a, b, c);
            switch (a) {
                case "ActualMinimumValue":
                case "ActualMaximumValue":
                    this.ai = SphericalMercatorVerticalScaler.am(this.n);
                    this.aj = SphericalMercatorVerticalScaler.am(this.n) - SphericalMercatorVerticalScaler.am(this.o);
                    break;
            }
        }
        static get as() {
            return SphericalMercatorVerticalScaler.ag;
        }
        static get at() {
            return SphericalMercatorVerticalScaler.ah;
        }
        getMercatorUnscaledValue(a, b, c, d) {
            let e = (a - c.top) * b.width + b.top * c.height;
            e = SphericalMercatorVerticalScaler.am(this.n) - e / (c.height / this.aj);
            return SphericalMercatorVerticalScaler.aq(e);
        }
        getMercatorScaledValue1(a, b, c, d) {
            let e = c.top + this.getMercatorScaledValue3(a, c.height);
            return (e - b.top * c.height) / b.width;
        }
        getMercatorScaledValue2(a, b, c, d, e) {
            let f = this.getMercatorScaledValue3(a, d.height);
            return (f - b.top * c.height) / b.width;
        }
        getMercatorScaledValue3(a, b) {
            a = a > SphericalMercatorVerticalScaler.ah ? (a < SphericalMercatorVerticalScaler.ag ? a : SphericalMercatorVerticalScaler.ag) : SphericalMercatorVerticalScaler.ah;
            let c = SphericalMercatorVerticalScaler.am(a);
            let d = (this.ai - c) * b / this.aj;
            return (d);
        }
        static am(a) {
            let b = a * (0.017453292519943295);
            let c = Math.sin(b);
            let d = 0.5 * Math.log((1 + c) / (1 - c));
            return d;
        }
        static aq(a) {
            a = Math.exp(2 * a);
            return Math.asin((a - 1) / (a + 1)) / 0.017453292519943295;
        }
        ak(a) {
            if (a < SphericalMercatorVerticalScaler.ah) {
                return SphericalMercatorVerticalScaler.ah;
            }
            if (a > SphericalMercatorVerticalScaler.ag) {
                return SphericalMercatorVerticalScaler.ag;
            }
            return a;
        }
    }
    SphericalMercatorVerticalScaler.$t = /*@__PURE__*/ markType(SphericalMercatorVerticalScaler, 'SphericalMercatorVerticalScaler', VerticalLinearScaler.$);
    SphericalMercatorVerticalScaler.ag = 85.05112878;
    SphericalMercatorVerticalScaler.ah = -85.05112878;
    return SphericalMercatorVerticalScaler;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SphericalMercatorHorizontalScaler = /*@__PURE__*/ (() => {
    class SphericalMercatorHorizontalScaler extends HorizontalLinearScaler {
        constructor() {
            super();
            this.aj = null;
            this.aj = new Rect(0, 0, 0, 1, 1);
        }
        q(a, b) {
            if (!b.c.isEmpty) {
                let c = a * b.e.width + b.e.left * b.d.width;
                let d = this.getMercatorUnscaledValue(c, this.aj, b.c, b.a);
                return d;
            }
            else {
                return this.getMercatorUnscaledValue(a, b.e, b.d, b.a);
            }
        }
        p(a, b) {
            if (!b.c.isEmpty) {
                let c = this.getMercatorScaledValue1(a, this.aj, b.c, b.a);
                let d = (c - (b.e.left * b.d.width)) / b.e.width;
                return d;
            }
            else {
                return this.getMercatorScaledValue1(a, b.e, b.d, b.a);
            }
        }
        af(values_) {
            let a = (Array.isArray(values_) ? values_ : null);
            return a;
            return null;
        }
        v(a, b, c, d) {
            let e;
            let f = d.e;
            let g = d.d;
            let h = d.c;
            let i = d.a;
            let j = !h.isEmpty;
            let k = this.m;
            let l = this.o;
            let m = h.left;
            let n = h.width;
            let o = f.left;
            let p = f.width;
            let q = g.left;
            let r = g.width;
            let s = this.aj.left;
            let t = this.aj.width;
            let u = this.af(a);
            let v = false;
            if (u != null) {
                v = true;
            }
            for (let w = b; w < c; w++) {
                if (v) {
                    e = u[w];
                }
                else {
                    e = a.item(w);
                }
                if (j) {
                    let x = (e - l) / (k);
                    if (i) {
                        x = 1 - x;
                    }
                    x = m + n * (x - s) / t;
                    let y = (x - (o * r)) / p;
                    if (v) {
                        u[w] = y;
                    }
                    else {
                        a.item(w, y);
                    }
                }
                else {
                    let z = (e - l) / (k);
                    if (i) {
                        z = 1 - z;
                    }
                    z = q + r * (z - o) / p;
                    if (v) {
                        u[w] = z;
                    }
                    else {
                        a.item(w, z);
                    }
                }
            }
        }
        t(a, b, c, d, e) {
            d = a.kj;
            e = a.ki;
            return {
                p3: d,
                p4: e
            };
        }
        getMercatorUnscaledValue(a, b, c, d) {
            let e = b.left + b.width * (a - c.left) / c.width;
            if (d) {
                e = 1 - e;
            }
            return this.o + e * (this.m);
        }
        getMercatorScaledValue1(a, b, c, d) {
            let e = (a - this.o) / (this.m);
            if (d) {
                e = 1 - e;
            }
            return c.left + c.width * (e - b.left) / b.width;
        }
        getMercatorScaledValue2(a, b, c, d, e) {
            let f = (a - this.o) / (this.m);
            if (e) {
                f = 1 - f;
            }
            return c.left + c.width * (f - b.left) / b.width;
        }
    }
    SphericalMercatorHorizontalScaler.$t = /*@__PURE__*/ markType(SphericalMercatorHorizontalScaler, 'SphericalMercatorHorizontalScaler', HorizontalLinearScaler.$);
    return SphericalMercatorHorizontalScaler;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ImageTilesReadyEventArgs = /*@__PURE__*/ (() => {
    class ImageTilesReadyEventArgs extends EventArgs {
    }
    ImageTilesReadyEventArgs.$t = /*@__PURE__*/ markType(ImageTilesReadyEventArgs, 'ImageTilesReadyEventArgs', EventArgs.$);
    return ImageTilesReadyEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ImagesChangedEventArgs = /*@__PURE__*/ (() => {
    class ImagesChangedEventArgs extends EventArgs {
    }
    ImagesChangedEventArgs.$t = /*@__PURE__*/ markType(ImagesChangedEventArgs, 'ImagesChangedEventArgs', EventArgs.$);
    return ImagesChangedEventArgs;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicMapSeriesHost = /*@__PURE__*/ (() => {
    class GeographicMapSeriesHost extends Series {
        constructor() {
            super();
            this.l1 = null;
            this.l3 = this.l2();
        }
        get_ct() {
            return true;
        }
        fs(a, b) {
            let c = this.gv(b);
            if (c == "LatitudeMemberPath") {
                c = "YMemberPath";
            }
            if (c == "LongitudeMemberPath") {
                c = "XMemberPath";
            }
            return this.l3.fs(a, b);
        }
        ch(a, b, c) {
            return this.l3.ch(a, b, c);
        }
        ag() {
            return this.l3.ag();
        }
        a5() {
            return this.l3;
        }
        get l3() {
            return this.l1;
        }
        set l3(a) {
            let b = this.l3 != a;
            if (b) {
                this.l1 = a;
                this.l8();
            }
        }
        l8() {
            if (this.l1 != null) {
                let hostedSeries_ = this.l1;
                hostedSeries_.externalObject = TypeRegistrar.createFromInternal(hostedSeries_, PlatformConstants.Prefix, PlatformConstants.Postfix);
                hostedSeries_.externalObject._implementation = hostedSeries_;
            }
            this.h1(this.l3);
            this.l4.bv();
        }
        fp(a) {
            return this.fu(this.l3, a);
        }
        bf() {
            return new HostSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.l4 = typeCast(HostSeriesView.$, a);
        }
        get l5() {
            return this.c(GeographicMapSeriesHost.ma);
        }
        set l5(a) {
            this.h(GeographicMapSeriesHost.ma, a);
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.l3.bs = this.bs;
                    if (c != null) {
                        c.jy(this.l3);
                    }
                    if (d != null) {
                        this.bs.hc(this.l3);
                    }
                    this.l3.i3(this.lz);
                    this.l3.fh = this.fh;
                    this.h6(this.l3);
                    this.fk = this.l3.fk;
                    let e = typeCast(SeriesViewer.$, c);
                    if (e != null) {
                        e.actualWindowRectChanged = delegateRemove(e.actualWindowRectChanged, runOn(this, this.l9));
                    }
                    if (this.bs != null) {
                        let f = this.bs;
                        f.actualWindowRectChanged = delegateCombine(f.actualWindowRectChanged, runOn(this, this.l9));
                    }
                    this.l7();
                    break;
                case "SyncLink":
                    this.l3.bn = this.bn;
                    break;
                case "VisibleFromScale":
                    this.l7();
                    break;
                case "Index":
                    this.l3.fh = this.fh;
                    break;
                case "ItemsSource":
                    this.l4.bw();
                    break;
                case "Resolution":
                    this.l4.by();
                    break;
                case "TransitionDuration":
                    this.l4.bz();
                    break;
                case "Opacity":
                    this.l4.bx();
                    break;
                case "Visibility":
                    let hs_ = this.l3;
                    let v_ = this._visibility;
                    hs_.visibility = v_;
                    break;
                case "MouseOverEnabled":
                    this.l3.c7 = this.c7;
                    break;
                case "ExpectFunctions":
                    this.l3.expectFunctions = this.expectFunctions;
                    break;
            }
        }
        l7() {
            if (this.bs == null || this.l3 == null) {
                return;
            }
            if (!isNaN_(this.l5)) {
                if (this.bs.mr.width > this.l5) {
                    let hs_ = this.l3;
                    let v_ = 1;
                    hs_.visibility = v_;
                }
                else {
                    let hs2_ = this.l3;
                    let v2_ = 0;
                    hs2_.visibility = v2_;
                }
            }
        }
        l9(a, b) {
            this.l7();
        }
        je(a) {
            super.je(a);
            if (this.l3 != null) {
                this.l3.je(a);
            }
        }
        jd(a, b, c, d, e) {
            if (this.l3 != null) {
                this.l3.jd(a, b, c, d, e);
            }
        }
        ar(a, b) {
            return this.l3.ar(a, b);
        }
        jn() {
            super.jn();
            this.l3.jn();
        }
        get_coercionMethods() {
            return this._coercionMethods;
        }
        set_coercionMethods(a) {
            this._coercionMethods = a;
            this.l3.coercionMethods = a;
        }
        h5(a) {
            super.h5(a);
            if (this.l3 != null) {
                let b = this.l3.fo();
                this.hy(a, b);
            }
        }
    }
    GeographicMapSeriesHost.$t = /*@__PURE__*/ markType(GeographicMapSeriesHost, 'GeographicMapSeriesHost', Series.$);
    GeographicMapSeriesHost.ma = /*@__PURE__*/ DependencyProperty.i("VisibleFromScale", Number_$type, GeographicMapSeriesHost.$, /*@__PURE__*/ new PropertyMetadata(2, 1, (a, b) => {
        let c = a;
        c.raisePropertyChanged("VisibleFromScale", b.oldValue, b.newValue);
    }));
    return GeographicMapSeriesHost;
})();
/**
 * @hidden
 */
let HostSeriesView = /*@__PURE__*/ (() => {
    class HostSeriesView extends SeriesView {
        constructor(a) {
            super(a);
            this.bu = null;
            this.bu = a;
        }
        ao(a, b) {
            super.ao(a, b);
        }
        bv() {
            this.bu.l3.itemsSource = this.bu.itemsSource;
            this.bu.l3.fh = this.bu.fh;
            this.bu.l3.k6 = this.bu.k6;
            this.bu.l3.k9 = this.bu.k9;
            this.bu.l3.eu = this.bu.eu;
            this.bu.l3.fi = this.bu.fi;
            this.bu.l3._opacity = this.bu._opacity;
        }
        bw() {
            this.bu.l3.itemsSource = this.bu.itemsSource;
        }
        by() {
            this.bu.l3.eu = this.bu.eu;
        }
        bz() {
            this.bu.l3.fi = this.bu.fi;
        }
        bx() {
            this.bu.l3._opacity = this.bu._opacity;
        }
    }
    HostSeriesView.$t = /*@__PURE__*/ markType(HostSeriesView, 'HostSeriesView', SeriesView.$);
    return HostSeriesView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let XamGeographicMap = /*@__PURE__*/ (() => {
    class XamGeographicMap extends SeriesViewer {
        constructor() {
            super();
            this.nv = null;
            this.nr = 0;
            this.oy = null;
            this.nf = null;
            this.nb = null;
            this.nd = null;
            this.nh = null;
            this.ou = { $type: Point_$type, x: NaN, y: NaN };
            this.o1 = null;
            this.nq = 1;
            this.imageTilesReady = null;
            this.nl = null;
            this.o0 = Rect.empty;
            this.nr = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.bottom) - SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
            this.ab = XamGeographicMap.$;
            this.backgroundContent = new OpenStreetMapImagery();
            let a = ((() => {
                let $ret = new NumericXAxis();
                $ret.bh = this;
                return $ret;
            })());
            a.b8 = true;
            this.nc = a;
            this.nc.ln = new SphericalMercatorHorizontalScaler();
            let b = ((() => {
                let $ret = new NumericYAxis();
                $ret.bh = this;
                return $ret;
            })());
            b.b8 = true;
            this.ne = b;
            this.ne.ln = new SphericalMercatorVerticalScaler();
            this.ob();
            this.oi();
            this.hs();
        }
        provideContainer(a) {
            super.provideContainer(a);
            this.nc.provideRenderer(a);
            this.ne.provideRenderer(a);
        }
        hs() {
            super.hs();
            this.nk.fm(this.ea);
        }
        c3() {
            return this.no;
        }
        c4() {
            return this.no;
        }
        get o3() {
            return this.oy;
        }
        set o3(a) {
            let b = Rect.l_op_Inequality(this.oy, a);
            if (b) {
                let c = this.oy;
                this.oy = a;
                this.ji("ActualWorldRect", c, a);
            }
        }
        o7() {
            return this.o3;
        }
        ob() {
            if (this.pf.isEmpty) {
                return;
            }
            this.o3 = this.pd(this.pf, true);
        }
        pd(a, b) {
            let c = a.top;
            let d = a.left;
            let e = a.width;
            let f = a.height;
            let g = SphericalMercatorVerticalScaler.am(a.bottom);
            let h = SphericalMercatorVerticalScaler.am(a.top);
            let i = g - h;
            let j = a.width / XamGeographicMap.oz.width;
            let k = SphericalMercatorVerticalScaler.am(XamGeographicMap.oz.top);
            let l = i / j;
            if (i / j > this.nr) {
                let m = i / this.nr;
                let n = m - j;
                d = d - (n / 2) * XamGeographicMap.oz.width;
                e = m * XamGeographicMap.oz.width;
                if (b) {
                    if (d < XamGeographicMap.oz.left) {
                        d += (XamGeographicMap.oz.left - d);
                    }
                    else if ((d + e) > XamGeographicMap.oz.right) {
                        d -= ((d + e) - XamGeographicMap.oz.right);
                    }
                }
            }
            else if (i / j < this.nr) {
                let o = this.nr * j;
                let p = o - i;
                let q = h - (p / 2);
                let r = g + (p / 2);
                if (b) {
                    if (q < k) {
                        q += (k - q);
                        r += (k - q);
                    }
                    else if (r > (k + this.nr)) {
                        q -= ((r) - (k + this.nr));
                        r -= ((r) - (k + this.nr));
                    }
                }
                c = SphericalMercatorVerticalScaler.aq(q);
                f = SphericalMercatorVerticalScaler.aq(r) - c;
            }
            let s = new Rect(0, d, c, e, f);
            return s;
        }
        get backgroundContent() {
            return this.nf;
        }
        set backgroundContent(a) {
            let b = a != this.backgroundContent;
            if (b) {
                let c = this.backgroundContent;
                this.nf = a;
                this.ji("BackgroundContent", c, a);
            }
        }
        get nc() {
            return this.nb;
        }
        set nc(a) {
            let b = a != this.nc;
            if (b) {
                let c = this.nc;
                this.nb = a;
                this.ji("XAxis", c, a);
            }
        }
        get ne() {
            return this.nd;
        }
        set ne(a) {
            let b = a != this.ne;
            if (b) {
                let c = this.ne;
                this.nd = a;
                this.ji("YAxis", c, a);
            }
        }
        getZoomRectFromGeoRect(a) {
            return this.getZoomFromGeographicRect(a);
        }
        ol(a) {
            this.m6 = a;
        }
        ok(a) {
            this.pf = a;
        }
        getZoomFromGeographicRect(a) {
            return this.o5(a, true, 0);
        }
        o4(a, b) {
            return this.o5(a, false, b);
        }
        o5(a, b, c) {
            let d = a;
            if (b) {
                d = this.pd(a, false);
            }
            let e = this.nc;
            let f = this.ne;
            let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, e.ca);
            g.c = this.mv;
            let h = new ScalerParams(1, XamGeographicMap.o2, this.m5, f.ca);
            h.c = this.mv;
            let i = this.nc.dy(d.left, g);
            let j = this.nc.dy(d.right, g);
            let k = this.ne.dy(d.top, h);
            let l = this.ne.dy(d.bottom, h);
            let m = (i - c) / this.m5.width;
            let n = (l - c) / this.m5.height;
            let o = (j - i + (c * 2)) / this.m5.width;
            let p = (k - l + (c * 2)) / this.m5.height;
            let q = new Rect(0, m, n, o, p);
            q.intersect(XamGeographicMap.o2);
            if (q.isEmpty) {
                q = XamGeographicMap.o2;
            }
            return q;
        }
        getZoomFromGeographicPoints(a, b) {
            let c = a.x;
            let d = b.y;
            let e = b.x - a.x;
            let f = a.y - b.y;
            if (e < 0 || f < 0) {
                return XamGeographicMap.o2;
            }
            else {
                let g = new Rect(0, c, d, e, f);
                return this.getZoomFromGeographicRect(g);
            }
        }
        o9(a) {
            let b = this.nc;
            let c = this.ne;
            let d = new ScalerParams(1, a, this.m5, b.ca);
            d.c = this.mv;
            let e = new ScalerParams(1, a, this.m5, c.ca);
            e.c = this.mv;
            let f = this.mu;
            let g = b.d1(f.left, d);
            let h = c.d1(f.top, e);
            let i = b.d1(f.right, d);
            let j = c.d1(f.bottom, e);
            let k = i - g;
            let l = h - j;
            let m = new Rect(0, g, j, k, l);
            m.intersect(XamGeographicMap.oz);
            if (m.isEmpty) {
                m = XamGeographicMap.oz;
            }
            return m;
        }
        ov(a) {
            let b = this.nc.km(a.x);
            let c = this.ne.km(a.y);
            return { $type: Point_$type, x: b, y: c };
        }
        ow(a) {
            let b = this.nc.ed(a.x);
            let c = this.ne.ed(a.y);
            return { $type: Point_$type, x: b, y: c };
        }
        ox(a) {
            return this.ow(a);
        }
        n8() {
            let a = typeCast(GeographicMapImagery.$, this.backgroundContent);
            if (a != null) {
                a.clearTileCache();
            }
        }
        oe(a) {
        }
        mb(a) {
            return this.nk.fq(a);
        }
        mc(a) {
            return this.nk.fr(a);
        }
        dh() {
            return true;
        }
        og() {
            this.nk.d7();
            for (let a of fromEnum(this.series)) {
                a.jn();
            }
        }
        oj() {
            if (this.nj == 2) {
                if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                    let a = this.nc.km(this.m5.left + (this.m5.width / 2));
                    let b = this.ne.km(this.m5.top + (this.m5.height / 2));
                    this.ou = { $type: Point_$type, x: a, y: b };
                }
            }
            else {
                if (!this.m5.isEmpty && this.m5.width > 0 && this.m5.height > 0) {
                    let c = this.nc.km(this.m5.left);
                    let d = this.ne.km(this.m5.top);
                    this.ou = { $type: Point_$type, x: c, y: d };
                }
            }
        }
        of() {
            if (isNaN_(this.ou.x) || isNaN_(this.ou.y)) {
                this.oj();
            }
            let a = this.ou.x;
            let b = this.ou.y;
            if (!isNaN_(a) && !isNaN_(b)) {
                let c = this.mr.left;
                let d = this.mr.top;
                let e = this.mr.width;
                let f = this.mr.height;
                if (e > this.o1.width) {
                }
                else {
                    let g = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
                    g.c = this.mv;
                    let h = this.nc.dy(a, g);
                    if (this.nj == 2) {
                        let i = h / this.m5.width;
                        c = i - (e / 2);
                    }
                    else {
                        c = h / this.m5.width;
                    }
                    if (c + e > this.o1.right) {
                        c = this.o1.right - e;
                    }
                    else if (c < this.o1.left) {
                        c = this.o1.left;
                    }
                }
                if (f > this.o1.height) {
                }
                else {
                    let j = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
                    j.c = this.mv;
                    let k = this.ne.dy(b, j);
                    if (this.nj == 2) {
                        let l = k / this.m5.height;
                        d = l - (f / 2);
                    }
                    else {
                        d = k / this.m5.height;
                    }
                    if (d + f > this.o1.bottom) {
                        d = this.o1.bottom - f;
                    }
                    else if (d < this.o1.top) {
                        d = this.o1.top;
                    }
                }
                this.km(new Rect(0, c, d, e, f), false);
            }
        }
        get_cx() {
            return true;
        }
        ms() {
            let a = super.ms();
            if (this.nc == null || this.ne == null) {
                return a;
            }
            let b = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.nc.ca);
            b.c = this.mv;
            let c = new ScalerParams(1, XamGeographicMap.o2, this.m5, this.ne.ca);
            c.c = this.mv;
            let d = this.nc.dy(XamGeographicMap.oz.left, b);
            let e = this.nc.dy(XamGeographicMap.oz.right, b);
            let f = this.ne.dy(XamGeographicMap.oz.top, c);
            let g = this.ne.dy(XamGeographicMap.oz.bottom, c);
            this.o1 = new Rect(0, d / this.m5.width, g / this.m5.height, (e - d) / this.m5.width, (f - g) / this.m5.height);
            let h = a.left;
            let i = a.top;
            if (this.m6.width > this.o1.width) {
                h = 0.5 - (this.m6.width / 2);
            }
            else if (h + a.width > this.o1.right) {
                h = this.o1.right - this.m6.width;
            }
            else if (h < this.o1.left) {
                h = this.o1.left;
            }
            if (this.m6.height > this.o1.height) {
                i = 0.5 - (this.m6.height / 2);
            }
            else if (i + this.m6.height > this.o1.bottom) {
                i = this.o1.bottom - this.m6.height;
            }
            else if (i < this.o1.top) {
                i = this.o1.top;
            }
            let j = new Rect(0, h, i, a.width, a.height);
            if (this.nn) {
                let k = this.o4(this.pf, 1);
                k = this.o6(k);
                let l = j.left + j.width / 2;
                let m = j.top + j.height / 2;
                if (j.width > k.width) {
                    let n = j.height / j.width;
                    let o = k.width;
                    let p = n * o;
                    j = new Rect(0, l - o / 2, m - p / 2, o, p);
                }
                if (j.height > k.height) {
                    let q = j.width / j.height;
                    let r = k.height;
                    let s = q * r;
                    j = new Rect(0, l - s / 2, m - r / 2, s, r);
                }
                if (j.left < k.left) {
                    j = new Rect(0, k.left, j.top, j.width, j.height);
                }
                if (j.top < k.top) {
                    j = new Rect(0, j.left, k.top, j.width, j.height);
                }
                if (j.right > k.right) {
                    j = new Rect(0, k.right - j.width, j.top, j.width, j.height);
                }
                if (j.bottom > k.bottom) {
                    j = new Rect(0, j.left, k.bottom - j.height, j.width, j.height);
                }
            }
            return j;
        }
        o6(a) {
            let b = this.ex;
            let c = 0.5 * (a.left + a.right);
            let d = 0.5 * (a.top + a.bottom);
            let e = a.width;
            let f = a.height;
            let g = MathUtil.b(a.width, b, 1);
            let h = MathUtil.b(a.height, b, 1);
            let i = this.m5;
            let j = i.width / i.height;
            let k = g * i.width;
            let l = h * i.height;
            let m = k / l;
            if (m != j) {
                if (l * j > k) {
                    k = l * j;
                    g = k / i.width;
                }
                else {
                    l = k / j;
                    h = l / i.height;
                }
            }
            let n = g != e;
            let o = h != f;
            let p = n ? c - 0.5 * g : a.left;
            let q = o ? d - 0.5 * h : a.top;
            let r = n ? c + 0.5 * g : a.right;
            let s = o ? d + 0.5 * h : a.bottom;
            if (p < 0) {
                p = 0;
                r = p + g;
            }
            if (r > 1) {
                r = 1;
                p = r - g;
            }
            if (q < 0) {
                q = 0;
                s = q + h;
            }
            if (s > 1) {
                s = 1;
                q = s - h;
            }
            return new Rect(0, p, q, r - p, s - q);
        }
        mt(a) {
            super.mt(this.m5);
            if (a.isEmpty) {
                return Rect.empty;
            }
            let b;
            if (a.width > a.height) {
                let c = intDivide(truncate((a.width - a.height)), 2);
                b = new Rect(0, a.left + c, a.top, a.height, a.height);
            }
            else {
                let d = intDivide(truncate((a.height - a.width)), 2);
                b = new Rect(0, a.left, a.top + d, a.width, a.width);
            }
            return b;
        }
        o8(a) {
            return this.mt(a);
        }
        bm() {
            return new XamGeographicMapView(this);
        }
        l7(a) {
            return this.nk.fp(a);
        }
        md(a) {
            return this.nk.fs(a);
        }
        oa(a) {
            if (a != null) {
                a.bh = this;
            }
        }
        i2(a) {
            super.i2(a);
            this.nk = a;
        }
        jd(a, b) {
            super.jd(a, b);
            this.kb(this.nc);
            this.kb(this.ne);
            if (Rect.l_op_Inequality(a, b)) {
                this.of();
            }
            if (this.nn) {
                this.mr = this.ms();
            }
            this.om();
        }
        get ns() {
            return this.nq;
        }
        set ns(a) {
            let b = this.nq;
            this.nq = a;
            this.ji("ActualWindowScale", b, this.nq);
        }
        eg() {
            return this.ns;
        }
        eh() {
            return this.ns;
        }
        ka() {
            super.ka();
            let a = Math.min(this.mr.width, this.mr.height);
            this.ns = a;
        }
        je(a, b, c, d) {
            super.je(a, b, c, d);
            switch (b) {
                case "WindowRect":
                    this.oj();
                    break;
                case XamGeographicMap.$$p[2]:
                    this.mr = this.ms();
                    break;
                case "BackgroundContent":
                    if (this.nh != null) {
                        let e = this.nh;
                        e.imageTilesReady = delegateRemove(e.imageTilesReady, runOn(this, this.oc));
                        this.nh.deferralHandler = null;
                    }
                    this.nh = typeCast(GeographicMapImagery.$, this.backgroundContent);
                    if (this.nh != null) {
                        let f = this.nh;
                        f.imageTilesReady = delegateCombine(f.imageTilesReady, runOn(this, this.oc));
                        this.nh.deferralHandler = this;
                    }
                    this.nk.fl(typeCast(GeographicMapImagery.$, c), typeCast(GeographicMapImagery.$, d));
                    if (this.nh != null) {
                        this.nh.geographicMap = this;
                        this.nk.fi(this.mr);
                        this.nk.fm(this.ea);
                    }
                    break;
                case "YAxis":
                case "XAxis":
                    this.oh(c);
                    this.oa(d);
                    break;
                case XamGeographicMap.$$p[4]:
                    if (!this.nm) {
                        this.m6 = XamGeographicMap.o2;
                    }
                    this.ob();
                    this.oi();
                    this.oj();
                    this.mr = this.ms();
                    this.nk.fj();
                    break;
                case "ActualWindowRect":
                    this.nk.fi(this.mr);
                    break;
                case "ActualWorldRect":
                    for (let g of fromEnum(this.series)) {
                        g.je(false);
                    }
                    break;
                case XamGeographicMap.$$p[3]:
                    this.ns = this.nt;
                    break;
                case "ActualWindowScale":
                    if (!this.dg) {
                        this.kl(this.eg(), this.eh());
                    }
                    break;
                case "ActualPixelScalingRatio":
                    this.nk.fm(this.ea);
                    break;
                case XamGeographicMap.$$p[5]:
                    this.kh();
                    break;
            }
        }
        oc(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new ImageTilesReadyEventArgs());
            }
        }
        oh(a) {
            if (a != null) {
                a.bh = null;
            }
        }
        oi() {
            if (this.nc != null) {
                this.nc.kj = this.o3.left;
                this.nc.ki = this.o3.right;
            }
            if (this.ne != null) {
                this.ne.kj = this.o3.top;
                this.ne.ki = this.o3.bottom;
            }
            this.nc.co(true);
            this.ne.co(true);
        }
        getFontInfo() {
            this.nl = this.nk.ff;
            return this.nl;
        }
        l6() {
            return this.nk.fn;
        }
        getFontBrush() {
            return this.nk.fo;
        }
        j5(a, b) {
            if (typeCast(ItfConverter.$, b) !== null) {
                let c = b;
                let d = a;
                d.itemsSource = c.triangulationSource.points;
                d.mc = c.triangulationSource.triangles;
            }
            else {
                super.j5(a, b);
            }
        }
        register(a, b) {
            this.jv(a, b);
        }
        unRegister(a) {
            this.j9(a);
        }
        deferredRefresh() {
            this.hh();
        }
        deferAction(a) {
            if (this.nv != null) {
                this.nv.setTimeout(a, 0);
            }
            else {
                window.setTimeout(a, 0);
            }
        }
        n9(a) {
            this.kg(a);
        }
        nw() {
            let a = new ChartVisualData();
            let b = this.nc.e5();
            let c = this.ne.e5();
            a.axes.add1(b);
            a.axes.add1(c);
            for (let d = 0; d < this.series.count; d++) {
                let e = this.series._inner[d].fo();
                a.series.add1(e);
            }
            a.name = this.name;
            a.contentArea = RectData.b(this.m5);
            a.centralArea = RectData.b(this.m5);
            a.plotArea = RectData.b(this.m5);
            return a;
        }
        my(a, b, c) {
            return a;
        }
        od() {
        }
        get pe() {
            return this.o0;
        }
        set pe(a) {
            this.o0 = a;
        }
        on(a) {
            this.pe = a;
            this.om();
        }
        om() {
            if (this.np && !this.pe.isEmpty) {
                let a = this.getZoomFromGeographicRect(this.pe);
                this.pe = Rect.empty;
                this.km(a, false);
            }
        }
        get np() {
            return !this.m5.isEmpty && !this.mv.isEmpty;
        }
    }
    XamGeographicMap.$t = /*@__PURE__*/ markType(XamGeographicMap, 'XamGeographicMap', SeriesViewer.$, [IMapRenderDeferralHandler_$type]);
    XamGeographicMap.ni = 0;
    XamGeographicMap.oz = /*@__PURE__*/ new Rect(2, { $type: Point_$type, x: -180, y: -85.05112878 }, { $type: Point_$type, x: 180, y: 85.05112878 });
    XamGeographicMap.o2 = /*@__PURE__*/ new Rect(0, 0, 0, 1, 1);
    XamGeographicMap.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, XamGeographicMap, 'ji', ['ResizeBehavior:nj:oo', [MapResizeBehavior_$type, /*@__PURE__*/ enumGetBox(MapResizeBehavior_$type, XamGeographicMap.ni)], 'SuppressZoomResetOnWorldRectChange:nm:op', [0, false], 'UseWorldRectForZoomBounds:nn:oq', [0, false], 'WindowScale:nt:or', [1, NaN], 'WorldRect:pf:os', [Rect.$, XamGeographicMap.oz], 'Zoomable:no:ot', [0, true]]);
    return XamGeographicMap;
})();
/**
 * @hidden
 */
let GeographicMapImagery = /*@__PURE__*/ (() => {
    class GeographicMapImagery extends Control {
        constructor(a) {
            super();
            this.ak = null;
            this.imageTilesReady = null;
            this.an = null;
            this.ap = null;
            this.propertyChanged = null;
            this.imagesChanged = null;
            this.cancellingImage = null;
            this.downloadingImage = null;
            this.ab = GeographicMapImagery.$;
            this.ap = a;
            this.aj = this.ai();
            this.a9(this.aj);
        }
        a9(a) {
        }
        ai() {
            return new GeographicMapImageryView(this);
        }
        get deferralHandler() {
            return this.ak;
        }
        set deferralHandler(a) {
            this.ak = a;
            if (this.ao != null) {
                this.ao.al = a;
            }
        }
        a3(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new ImageTilesReadyEventArgs());
            }
        }
        a7() {
            let a = this.ao;
            a.imageTilesReady = delegateCombine(a.imageTilesReady, runOn(this, this.a3));
            this.ao.al = this.deferralHandler;
            let b = this.ao;
            b.imagesChanged = delegateCombine(b.imagesChanged, runOn(this, this.a2));
            let c = this.ao;
            c.downloadingImage = delegateCombine(c.downloadingImage, runOn(this, this.a1));
            let d = this.ao;
            d.cancellingImage = delegateCombine(d.cancellingImage, runOn(this, this.a0));
            this.ao.bc = this.referer;
            this.ao.bg = this.userAgent;
        }
        a1(a, b) {
            if (this.downloadingImage != null) {
                this.downloadingImage(this, b);
            }
        }
        a0(a, b) {
            if (this.cancellingImage != null) {
                this.cancellingImage(this, b);
            }
        }
        be() {
            if (this.ao != null) {
                this.aj.e();
            }
        }
        a8(a, b, c) {
            switch (a) {
                case GeographicMapImagery.$$p[2]:
                    this.be();
                    break;
                case "GeographicMap":
                    this.aj.e();
                    break;
                case GeographicMapImagery.$$p[0]:
                    if (this.ao != null) {
                        this.ao.bc = this.referer;
                    }
                    break;
                case GeographicMapImagery.$$p[1]:
                    if (this.ao != null) {
                        this.ao.bg = this.userAgent;
                    }
                    break;
            }
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
        get geographicMap() {
            return this.c(GeographicMapImagery.geographicMapProperty);
        }
        set geographicMap(a) {
            this.h(GeographicMapImagery.geographicMapProperty, a);
        }
        static a6(a, b) {
            a.a5(b.oldValue, b.newValue);
        }
        a5(a, b) {
            this.a8("GeographicMap", a, b);
        }
        clearTileCache() {
            if (this.ao != null) {
                this.ao.bp(0, 0, 0, 0);
            }
        }
        get ao() {
            return this.an;
        }
        set ao(a) {
            this.an = a;
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs("MultiScaleImage"));
            }
        }
        bk(a) {
            if (this.geographicMap == null || a.width < 1 || a.height < 1) {
                return a;
            }
            let b = new Rect(0, 0, 0, a.width, a.height);
            let c = this.geographicMap.o8(b);
            let d = XamGeographicMap.oz;
            let e = this.geographicMap.o3;
            let f = Math.min(this.windowRect.height, this.windowRect.width);
            let g = e.width / d.width;
            this.ao.a3 = (b.width / c.width) * f * g;
            let h = this.geographicMap.nc;
            let i = this.geographicMap.ne;
            let j = new ScalerParams(1, this.windowRect, b, h.ca);
            j.c = c;
            let k = new ScalerParams(1, this.windowRect, b, i.ca);
            k.c = c;
            let l = h.dy(d.left, j);
            let m = i.dy(d.bottom, k);
            let n = (-l / b.width) * this.ao.a3;
            let o = (-m / b.height) * this.ao.a3 * (b.height / b.width);
            this.ao.ci = { $type: Point_$type, x: n, y: o };
            return a;
        }
        bb(a) {
            this.aj.f(a);
        }
        bd(a) {
            this.aj.h(a);
        }
        bc(a) {
            this.aj.g(a);
        }
        a2(a, b) {
            if (this.imagesChanged != null) {
                this.imagesChanged(this, new ImagesChangedEventArgs());
            }
        }
        a4() {
            this.aj.e();
        }
        ba(a) {
            this.aj.i(a);
        }
        v() {
            super.v();
            this.ap.m = this._opacity;
        }
    }
    GeographicMapImagery.$t = /*@__PURE__*/ markType(GeographicMapImagery, 'GeographicMapImagery', Control.$, [INotifyPropertyChanged_$type]);
    GeographicMapImagery.geographicMapProperty = /*@__PURE__*/ DependencyProperty.i("GeographicMap", XamGeographicMap.$, GeographicMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, GeographicMapImagery.a6));
    GeographicMapImagery.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicMapImagery, 'a8', ['Referer', [2, null], 'UserAgent', [2, null], 'WindowRect', [Rect.$, Rect.empty]]);
    return GeographicMapImagery;
})();
/**
 * @hidden
 */
let GeographicMapImageryView = /*@__PURE__*/ (() => {
    class GeographicMapImageryView extends Base {
        constructor(a) {
            super();
            this.a = null;
            this.j = null;
            this.d = null;
            this.b = 1;
            this.j = Rect.empty;
            this.a = a;
            this.a.ao = new XamMultiScaleImage();
            this.a.ao.ao = this.a.ap;
            this.a.a7();
        }
        e() {
            if (this.j.isEmpty) {
                return;
            }
            this.a.bk(new Size(1, this.j.width, this.j.height));
        }
        f(a) {
            this.a.ao.by(a);
        }
        g(a) {
            this.d = a;
            this.a.ao.bz(a);
        }
        h(a) {
            this.j = a;
            this.a.ao.b0(a);
            this.a.a4();
        }
        get c() {
            return this.b;
        }
        i(a) {
            this.b = a;
            this.a.ao.bw(a);
        }
    }
    GeographicMapImageryView.$t = /*@__PURE__*/ markType(GeographicMapImageryView, 'GeographicMapImageryView');
    return GeographicMapImageryView;
})();
/**
 * @hidden
 */
let GeographicXYTriangulatingSeriesView = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeriesView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            super.bv();
            let a = this.b0.l3;
            a.mz = this.b0.mf;
            a.m3 = this.b0.md;
            a.trianglesSource = this.b0.mc;
            a.mr = this.b0.mi;
            a.mt = this.b0.mk;
            a.mv = this.b0.mm;
        }
        b3() {
            let a = this.b0.l3;
            if (this.b0.bs == null) {
                a.l1 = null;
                a.l2 = null;
                return;
            }
            a.l1 = this.b0.bs.nc;
            a.l2 = this.b0.bs.ne;
        }
        b2() {
            this.b0.l3.mz = this.b0.mf;
        }
        b1() {
            this.b0.l3.m3 = this.b0.md;
        }
        b4() {
            this.b0.l3.trianglesSource = this.b0.mc;
        }
        b5() {
            this.b0.l3.mr = this.b0.mi;
        }
        b6() {
            this.b0.l3.mt = this.b0.mk;
        }
        b7() {
            this.b0.l3.mv = this.b0.mm;
        }
    }
    GeographicXYTriangulatingSeriesView.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeriesView, 'GeographicXYTriangulatingSeriesView', HostSeriesView.$);
    return GeographicXYTriangulatingSeriesView;
})();
/**
 * @hidden
 */
let GeographicScatterAreaSeriesView = /*@__PURE__*/ (() => {
    class GeographicScatterAreaSeriesView extends GeographicXYTriangulatingSeriesView {
        constructor(a) {
            super(a);
            this.b8 = null;
            this.b8 = a;
        }
        bv() {
            super.bv();
            if (this.b8.mw != null) {
                this.b8.mw.nu = this.b8.mz;
                this.b8.mw.nm = this.b8.mv;
            }
        }
        b9() {
            if (this.b8.mw != null) {
                this.b8.mw.nu = this.b8.mz;
            }
        }
        ca() {
            if (this.b8.mw != null) {
                this.b8.mw.nm = this.b8.mv;
            }
        }
    }
    GeographicScatterAreaSeriesView.$t = /*@__PURE__*/ markType(GeographicScatterAreaSeriesView, 'GeographicScatterAreaSeriesView', GeographicXYTriangulatingSeriesView.$);
    return GeographicScatterAreaSeriesView;
})();
/**
 * @hidden
 */
let XamGeographicMapView = /*@__PURE__*/ (() => {
    class XamGeographicMapView extends SeriesViewerView {
        constructor(a) {
            super(a);
            this.fe = null;
            this.fu = null;
            this.fo = null;
            this.fn = null;
            this.ff = null;
            this.fg = NaN;
            this.fu = Rect.empty;
            this.fe = a;
            this.fe.l1 = 2;
            this.fe.ex = 5E-06;
        }
        k(a) {
            return 2;
        }
        bi(a) {
            this.i.bv(a);
            this.fe.n9(a);
            this.ee();
        }
        get_an() {
            return true;
        }
        dx() {
            let a;
            let b;
            let c;
            let d;
            let e;
            let f = this.i.a7(a, b, c, d, e);
            a = f.p0;
            b = f.p1;
            c = f.p2;
            d = f.p3;
            e = f.p4;
            this.fo = c;
            this.ff = d;
            this.fn = e;
        }
        fq(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(0,0,0,1)";
                return $ret;
            })());
        }
        fr(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "white";
                return $ret;
            })());
        }
        fp(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(50,50,50,.5)";
                return $ret;
            })());
        }
        fs(a) {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "white";
                return $ret;
            })());
        }
        dm(a) {
            super.dm(a);
            if (this.fe.backgroundContent != null) {
                let b = this.fe.backgroundContent;
                b.bc(this.i.ae);
                b.bb(a);
            }
        }
        dn(a) {
            super.dn(a);
            this.fu = a;
            if (this.fe.backgroundContent != null) {
                let b = this.fe.backgroundContent;
                b.bd(this.fu);
            }
        }
        ft() {
            return new Rect(0, 0, 0, this.fu.width, this.fu.height);
        }
        fj() {
            if (this.fe.backgroundContent != null) {
                let a = this.fe.backgroundContent;
                a.a4();
            }
        }
        fi(a) {
            if (this.fe.nh != null) {
                this.fe.nh.windowRect = a;
            }
        }
        fl(a, b) {
            if (this.fe.nh != null) {
                this.fe.nh.windowRect = this.fe.mr;
            }
            if (a != null) {
                let c = a.ao;
                if (c != null) {
                    this.fe.ah.e.remove(c.ag);
                }
                a.bb(null);
                a.bc(null);
            }
            if (b != null) {
                let d = b.ao;
                if (d != null) {
                    this.fe.ah.e.add(d.ag);
                }
                if (!this.fu.isEmpty) {
                    this.dn(this.fu);
                }
                if (this.u != null) {
                    this.dm(this.u);
                }
            }
            if (b == null) {
                this.fk(this.u);
            }
        }
        fk(a) {
            let b = this.fe.ea;
            if (b != 1) {
                a.z();
                a.aa(b, b);
            }
            a.k(this.fu.left, this.fu.top, this.fu.width, this.fu.height);
            if (b != 1) {
                a.y();
            }
        }
        du() {
            this.e6.ac = 1;
            this.e7.ac = 1;
            this.e6._stroke = this.fo;
            this.e7._stroke = this.fo;
            super.du();
        }
        fm(a) {
            this.fg = a;
            if (this.fe.backgroundContent != null) {
                this.fe.backgroundContent.ba(a);
            }
        }
        get fh() {
            return this.fg;
        }
        set fh(a) {
            this.fg = a;
        }
    }
    XamGeographicMapView.$t = /*@__PURE__*/ markType(XamGeographicMapView, 'XamGeographicMapView', SeriesViewerView.$);
    return XamGeographicMapView;
})();
/**
 * @hidden
 */
let OpenStreetMapImagery = /*@__PURE__*/ (() => {
    class OpenStreetMapImagery extends GeographicMapImagery {
        constructor() {
            super(new OpenStreetMapTileSource());
        }
        get tilePath() {
            return this.c(OpenStreetMapImagery.tilePathProperty);
        }
        set tilePath(a) {
            this.h(OpenStreetMapImagery.tilePathProperty, a);
        }
        static bo(a, b) {
            a.bn("TilePath", b.oldValue, b.newValue);
        }
        bn(a, b, c) {
            switch (a) {
                case "TilePath":
                    this.ap.setTilePathUrl(c == null ? null : c);
                    this.aj.e();
                    break;
            }
            super.a8(a, b, c);
        }
    }
    OpenStreetMapImagery.$t = /*@__PURE__*/ markType(OpenStreetMapImagery, 'OpenStreetMapImagery', GeographicMapImagery.$);
    OpenStreetMapImagery.tilePathProperty = /*@__PURE__*/ DependencyProperty.i("TilePath", String_$type, OpenStreetMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, OpenStreetMapImagery.bo));
    return OpenStreetMapImagery;
})();
/**
 * @hidden
 */
let GeographicXYTriangulatingSeries = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeries extends GeographicMapSeriesHost {
        bf() {
            return new GeographicXYTriangulatingSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mb = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.mb.b3();
                    break;
                case GeographicXYTriangulatingSeries.$$p[1]:
                    this.mb.b2();
                    break;
                case GeographicXYTriangulatingSeries.$$p[0]:
                    this.mb.b1();
                    break;
                case GeographicXYTriangulatingSeries.$$p[2]:
                    this.mb.b4();
                    break;
                case GeographicXYTriangulatingSeries.$$p[3]:
                    this.mb.b5();
                    break;
                case GeographicXYTriangulatingSeries.$$p[4]:
                    this.mb.b6();
                    break;
                case GeographicXYTriangulatingSeries.$$p[5]:
                    this.mb.b7();
                    break;
            }
        }
    }
    GeographicXYTriangulatingSeries.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeries, 'GeographicXYTriangulatingSeries', GeographicMapSeriesHost.$);
    GeographicXYTriangulatingSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicXYTriangulatingSeries, 'raisePropertyChanged', ['LatitudeMemberPath:md:mo', [2, "pointY"], 'LongitudeMemberPath:mf:mp', [2, "pointX"], 'TrianglesSource:mc:mq', [IEnumerable_$type, null], 'TriangleVertexMemberPath1:mi:mr', [2, "v1"], 'TriangleVertexMemberPath2:mk:ms', [2, "v2"], 'TriangleVertexMemberPath3:mm:mt', [2, "v3"]]);
    return GeographicXYTriangulatingSeries;
})();
/**
 * @hidden
 */
let GeographicScatterAreaSeries = /*@__PURE__*/ (() => {
    class GeographicScatterAreaSeries extends GeographicXYTriangulatingSeries {
        constructor() {
            super();
            this.mu = null;
            this.triangulationStatusChanged = null;
            this.ab = GeographicScatterAreaSeries.$;
        }
        get mv() {
            return this.mu;
        }
        set mv(a) {
            let b = this.mu != a;
            if (b) {
                let c = this.mu;
                this.mu = a;
                this.raisePropertyChanged("ColorScale", c, this.mu);
                if (this.mw != null) {
                    this.mw.nm = a;
                }
            }
        }
        l2() {
            this.mw = new ScatterAreaSeries();
            let a = this.mw;
            a.triangulationStatusChanged = delegateCombine(a.triangulationStatusChanged, runOn(this, this.m2));
            return this.mw;
        }
        m2(a, b) {
            if (this.triangulationStatusChanged != null) {
                this.triangulationStatusChanged(this, b);
            }
        }
        bf() {
            return new GeographicScatterAreaSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.my = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case GeographicScatterAreaSeries.$$p[0]:
                    this.my.b9();
                    break;
                case "ColorScale":
                    this.my.ca();
                    break;
            }
        }
        get_dq() {
            return true;
        }
        set_dq(a) {
            super.set_dq(a);
        }
    }
    GeographicScatterAreaSeries.$t = /*@__PURE__*/ markType(GeographicScatterAreaSeries, 'GeographicScatterAreaSeries', GeographicXYTriangulatingSeries.$);
    GeographicScatterAreaSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicScatterAreaSeries, 'raisePropertyChanged', ['ColorMemberPath:mz:m3', [2, "value"]]);
    return GeographicScatterAreaSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

class IgrImageTilesReadyEventArgs {
    createImplementation() {
        return new ImageTilesReadyEventArgs();
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Represents the Infragistics IgxGeographicMapComponent control.
*/
class IgrGeographicMap extends IgrSeriesViewer {
    constructor(props) {
        super(props);
        this.contentSeries = [];
        /**
         * The series actually present in the chart. Do not directly modify this array.
         * This array's contents can be modified by causing React to reproject the child content.
         * Or adding and removing series from the manual series collection on the series property.
         */
        this.actualSeries = [];
        this._series = null;
        this._initialized = false;
        this._seriesAdapter = null;
        this._defaultTooltips = null;
        this._uniqueTooltipId = 0;
        this._imageTilesReady = null;
        this._imageTilesReady_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._getMainRef = this._getMainRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        this._contentChildrenManager = new ContentChildrenManager((ch) => ch.key || ch.props.name, (ch) => ch.key || ch.props.name, () => this._updateContentChildren());
        if (document) {
            this._container = document.createElement("div");
            this._container.style.display = "block";
            this._container.style.width = "100%";
            this._container.style.height = "100%";
        }
        var root;
        root = this._container;
        var ren = new ReactRenderer(root, document, true, DataChartStylingDefaults);
        this._wrapper = ren;
        var chart = this.i;
        this._chart = chart;
        this._seriesAdapter = new CollectionAdapter(this.contentSeries, this.i.series, this.actualSeries, (c) => c.i, (i) => {
            i.owner = this;
            i._provideRenderer(this._dataSource);
            i.provideData(this._dataSource);
            if (this._container && this._container.parentElement) {
                i._styling(this._container, this, this);
            }
            this._ensureDefaultTooltip(i);
            this._ensureTooltipCreated(i);
        }, (i) => { i._provideRenderer(null); i.provideData(null); });
        chart.provideContainer(ren);
        ren.addSizeWatcher(() => {
            this._chart.notifyContainerResized();
        });
        this._initialized = true;
    }
    set height(value) {
        this._height = value;
        if (this._elRef) {
            this._elRef.style.height = value;
            this._chart.notifyContainerResized();
        }
    }
    get height() {
        return this._height;
    }
    /**
     * Gets or sets the legend used for the current chart.
    */
    get legend() {
        if (this.i.legend != null)
            return this.i.legend.externalObject;
    }
    set legend(v) {
        if (v != undefined && v != null)
            this.i.legend = v.i;
    }
    _updateContentChildren() {
        this.contentSeries.length = 0;
        let contentChildrenActual = this._contentChildrenManager.contentChildrenActual;
        for (let i = 0; i < contentChildrenActual.length; i++) {
            this.contentSeries.push(contentChildrenActual[i]);
        }
        if (this._seriesAdapter !== null) {
            this._seriesAdapter.notifyContentChanged();
        }
    }
    _getMainRef(ref) {
        this._elRef = ref;
    }
    render() {
        // if (!this._childrenDiffer(this.props.children)) {
        // 	let div = React.createElement("div", {
        // 		ref: (ref) => {
        // 			this._elRef = ref;
        // 		},
        // 		children: this.props.children
        // 	});
        // 	return div;
        // } else {
        let children = this._contentChildrenManager.getChildren(this.props.children);
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            //children = React.Children.toArray(this.props.children);
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    children.push(this._activeTooltipElements.get(t));
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    children.push(portal);
                }
            }
        }
        let div = createElement("div", {
            className: "ig-geographic-map igr-geographic-map",
            ref: this._getMainRef,
            children: children
        });
        return div;
        //}
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    componentDidMount() {
        super.componentDidMount();
        this._elRef.style.width = this._width ? this._width : "";
        this._elRef.style.height = this._height ? this._height : "";
        this._elRef.appendChild(this._container);
        this._chart.notifyContainerResized();
        this.initializeContent();
    }
    set width(value) {
        this._width = value;
        if (this._elRef) {
            this._elRef.style.width = value;
            this._chart.notifyContainerResized();
        }
    }
    get width() {
        return this._width;
    }
    /**
     * A collection or manually added series for the chart.
    */
    get series() {
        if (this._series === null) {
            let coll = new IgrSeriesCollection();
            let inner = coll._innerColl;
            inner.addListener((sender, e) => {
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._seriesAdapter.addManualItem(e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._seriesAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._seriesAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._seriesAdapter.clearManualItems();
                        break;
                }
            });
            this._series = coll;
        }
        return this._series;
    }
    componentWillUnmount() {
        this._chart.destroy();
        this._wrapper.destroy();
    }
    createImplementation() {
        return new XamGeographicMap();
    }
    set dataSource(value) {
        this._dataSource = value;
        this.bindData();
    }
    get dataSource() {
        return this._dataSource;
    }
    bindData() {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i].provideData(this._dataSource);
            }
        }
    }
    initializeContent() {
        if (TypeRegistrar.isRegistered("IgrDataChartDefaultTooltips")) {
            let d = TypeRegistrar.create("IgrDataChartDefaultTooltips");
            this._defaultTooltips = d;
            this._onDefaultTooltipsReady(d);
            //this._container.appendChild(cr.location.nativeElement);
        }
        this._styling(this._container, this);
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                currSeries[i]._styling(this._container, this, this);
            }
        }
        this.i.notifyContainerResized();
    }
    _ensureTooltipCreated(series) {
        series._ensureTooltipCreated(() => this.createTooltip(), (ele) => {
            let wrapper = new ReactWrapper(ele, this._wrapper);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
            return wrapper;
        });
    }
    _ensureDefaultTooltip(series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](series);
    }
    _onDefaultTooltipsReady(cr) {
        if (this.actualSeries && this.actualSeries.length > 0) {
            var currSeries = this.actualSeries;
            for (var i = 0; i < currSeries.length; i++) {
                if (currSeries[i].showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries[i]);
                }
            }
        }
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    /**
     * An imagery to display behind all series, inside the viewport of the IgrGeographicMapComponent control.
    */
    get backgroundContent() {
        if (this.i.backgroundContent != null) {
            return this.i.backgroundContent.externalObject;
        }
        else {
            return null;
        }
    }
    set backgroundContent(v) {
        if (v != undefined && v != null) {
            this.i.backgroundContent = v.i;
        }
        else {
            this.i.backgroundContent = null;
        }
    }
    /**
                             * @hidden
                             */
    get i() {
        return this._implementation;
    }
    /**
 * Gets or sets zoomability of the current control
*/
    get zoomable() {
        return this.i.no;
    }
    set zoomable(v) {
        this.i.no = ensureBool(v);
    }
    /**
     * Gets or sets the behavior to use during resize.
    */
    get resizeBehavior() {
        return this.i.nj;
    }
    set resizeBehavior(v) {
        this.i.nj = ensureEnum(MapResizeBehavior_$type, v);
    }
    /**
     * Gets or sets whether to use the uncoerced world rect to constrain the zoom bounds.
    */
    get useWorldRectForZoomBounds() {
        return this.i.nn;
    }
    set useWorldRectForZoomBounds(v) {
        this.i.nn = ensureBool(v);
    }
    /**
     * Gets or sets whether skip resetting the zoom when the world rect changes.
    */
    get suppressZoomResetOnWorldRectChange() {
        return this.i.nm;
    }
    set suppressZoomResetOnWorldRectChange(v) {
        this.i.nm = ensureBool(v);
    }
    /**
     * Gets or sets the world bounding rectangle.
    */
    get worldRect() {
        return fromRect(this.i.pf);
    }
    set worldRect(v) {
        this.i.pf = toRect(v);
    }
    /**
     * Gets the actual value of the WorldRect.
    */
    get actualWorldRect() {
        return fromRect(this.i.o3);
    }
    set actualWorldRect(v) {
        this.i.o3 = toRect(v);
    }
    /**
     * The X-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get xAxis() {
        if (this.i.nc == null) {
            return null;
        }
        if (!this.i.nc.externalObject) {
            let e = IgrNumericXAxis._createFromInternal(this.i.nc);
            if (e) {
                e._implementation = this.i.nc;
            }
            this.i.nc.externalObject = e;
        }
        return this.i.nc.externalObject;
    }
    set xAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.nc = null : this.i.nc = v.i;
    }
    /**
     * The Y-axis for this IgxGeographicMap.Component
     * Under normal circumstances, this property should not be set in application code.  By default, it will be set to a numeric axis with a spherical mercator scaler.
    */
    get yAxis() {
        if (this.i.ne == null) {
            return null;
        }
        if (!this.i.ne.externalObject) {
            let e = IgrNumericYAxis._createFromInternal(this.i.ne);
            if (e) {
                e._implementation = this.i.ne;
            }
            this.i.ne.externalObject = e;
        }
        return this.i.ne.externalObject;
    }
    set yAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.ne = null : this.i.ne = v.i;
    }
    /**
     * Indicates if this SeriesViewer is a map.
    */
    get isMap() {
        return this.i.cx;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the WindowRect property.
    */
    get windowScale() {
        return this.i.nt;
    }
    set windowScale(v) {
        this.i.nt = +v;
    }
    /**
     * A number between 0 and 1 determining the scale of the horizontal/vertical zoom.
     * This property is effectively a shortcut to the Width/Height of the ActualWindowRect property.
    */
    get actualWindowScale() {
        return this.i.ns;
    }
    set actualWindowScale(v) {
        this.i.ns = +v;
    }
    /**
     * Gets whether or not the control is ready for zooming
    */
    get zoomIsReady() {
        return this.i.np;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.backgroundContent && this.backgroundContent.name && this.backgroundContent.name == name) {
            return this.backgroundContent;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.xAxis && this.xAxis._styling) {
            this.xAxis._styling(container, component, this);
        }
        if (this.yAxis && this.yAxis._styling) {
            this.yAxis._styling(container, component, this);
        }
        this._inStyling = false;
    }
    getCurrentActualWorldRect() {
        let iv = this.i.o7();
        return fromRect(iv);
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomRectFromGeoRect(geographic) {
        let iv = this.i.getZoomRectFromGeoRect(toRect(geographic));
        return fromRect(iv);
    }
    updateZoomWindow(zoomWindow) {
        this.i.ol(toRect(zoomWindow));
    }
    updateWorldRect(worldRect) {
        this.i.ok(toRect(worldRect));
    }
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
    
    * @param geographic  * The geographic area.
    */
    getZoomFromGeographicRect(geographic) {
        let iv = this.i.getZoomFromGeographicRect(toRect(geographic));
        return fromRect(iv);
    }
    convertGeographicToZoom(geographic, extraPixelPadding) {
        let iv = this.i.o4(toRect(geographic), extraPixelPadding);
        return fromRect(iv);
    }
    getZoomFromGeographicPoints(northWest, southEast) {
        let iv = this.i.getZoomFromGeographicPoints(toPoint(northWest), toPoint(southEast));
        return fromRect(iv);
    }
    /**
     * Given a WindowRect and the current plot area, get the geographic region represented by that WindowRect.
    
    * @param windowRect  * The zoom area.
    */
    getGeographicFromZoom(windowRect) {
        let iv = this.i.o9(toRect(windowRect));
        return fromRect(iv);
    }
    /**
     * Convert a pixel-based coordinate to a geographic coordinate.
    
    * @param pixelCoordinate  * A pixel-based coordinate
    */
    getGeographicPoint(pixelCoordinate) {
        let iv = this.i.ov(toPoint(pixelCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getPixelPoint(geographicCoordinate) {
        let iv = this.i.ow(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Convert a geographic coordinate to a pixel-based coordinate.
    
    * @param geographicCoordinate  * A geographic coordinate
    */
    getWindowPoint(geographicCoordinate) {
        let iv = this.i.ox(toPoint(geographicCoordinate));
        return fromPoint(iv);
    }
    /**
     * Removes all cached tile images from the map imagery assigned to the map's background content.
    
    */
    clearTileCache() {
        this.i.n8();
    }
    /**
     * Notifies the chart that the CSS styles in effect have been updated.
    
    */
    styleUpdated() {
        this.i.og();
    }
    /**
     * Gets actual window scale for horizontal dimension of the control
    
    */
    getActualWindowScaleHorizontal() {
        let iv = this.i.eg();
        return (iv);
    }
    /**
     * Gets actual window scale for vertical dimension of the control
    
    */
    getActualWindowScaleVertical() {
        let iv = this.i.eh();
        return (iv);
    }
    /**
     * Calls for a deferred refresh to the GeographicMap's background.
    
    */
    deferredRefresh() {
        this.i.deferredRefresh();
    }
    /**
     * Returns the chart visuals expressed as a ChartVisualData object.
    
    */
    exportVisualData() {
        let iv = this.i.nw();
        return (iv);
    }
    /**
     * Zoom in to the geographic region specified, when possible (may need to wait for map to be initialized).
    
    * @param geographic  * The geographic region to zoom to.
    */
    zoomToGeographic(geographic) {
        this.i.on(toRect(geographic));
    }
    /**
     * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
    */
    get imageTilesReady() {
        return this._imageTilesReady;
    }
    set imageTilesReady(ev) {
        if (this._imageTilesReady_wrapped !== null) {
            this.i.imageTilesReady = delegateRemove(this.i.imageTilesReady, this._imageTilesReady_wrapped);
            this._imageTilesReady_wrapped = null;
            this._imageTilesReady = null;
        }
        this._imageTilesReady = ev;
        this._imageTilesReady_wrapped = (o, e) => {
            let outerArgs = new IgrImageTilesReadyEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeImageTilesReady) {
                this.beforeImageTilesReady(this, outerArgs);
            }
            if (this._imageTilesReady) {
                this._imageTilesReady(this, outerArgs);
            }
        };
        this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, this._imageTilesReady_wrapped);
    }
}

class IgrSubDomainsCollection extends IgCollection {
    constructor(list) {
        super();
        if (list) {
            for (let i = 0; i < list.length; i++) {
                this.add(list[i]);
            }
        }
    }
    _createInnerColl() {
        let coll = new SyncableObservableCollection$2(String_$type, String_$type, 0);
        coll.compare = (ext, int) => {
            let comp = ext;
            if (comp.equals) {
                return comp.equals(int);
            }
            return comp === int;
        };
        coll.createTo = (ext) => {
            return ext;
        };
        coll.createFrom = (int) => {
            return int;
        };
        return coll;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * Describes available map styles for the Bing Maps imagery.
 */
var BingMapsImageryStyle = /*@__PURE__*/ (function (BingMapsImageryStyle) {
    /**
     * Specifies the Aerial map style without road or labels overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["Aerial"] = 0] = "Aerial";
    /**
     * Specifies the Aerial map style with road and labels overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["AerialWithLabels"] = 1] = "AerialWithLabels";
    /**
     * Specifies the Roads map style without aerial overlay.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["Road"] = 2] = "Road";
    /**
     * Specifies a dark version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasDark"] = 3] = "CanvasDark";
    /**
     * Specifies a lighter version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasLight"] = 4] = "CanvasLight";
    /**
     * Specifies a grayscale version of the Roads maps.
     */
    BingMapsImageryStyle[BingMapsImageryStyle["CanvasGray"] = 5] = "CanvasGray";
    return BingMapsImageryStyle;
})({});
/**
 * @hidden
 */
let BingMapsImageryStyle_$type = /*@__PURE__*/ markEnum('BingMapsImageryStyle', 'Aerial,0|AerialWithLabels,1|Road,2|CanvasDark,3|CanvasLight,4|CanvasGray,5');

class IgrImagesChangedEventArgs {
    createImplementation() {
        return new ImagesChangedEventArgs();
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
}

/**
 * Control class used for displaying multi-scale TileSource imagery.  Designed to be used for background imagery in the IgxGeographicMap.Component
*/
class IgrGeographicMapImagery {
    constructor() {
        this._imageTilesReady = null;
        this._imageTilesReady_wrapped = null;
        this._imagesChanged = null;
        this._imagesChanged_wrapped = null;
        this._cancellingImage = null;
        this._cancellingImage_wrapped = null;
        this._downloadingImage = null;
        this._downloadingImage_wrapped = null;
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return null;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    /**
     * The deferral handler to use for deferred refreshes.
    */
    get deferralHandler() {
        return this.i.deferralHandler;
    }
    set deferralHandler(v) {
        this.i.deferralHandler = v;
    }
    /**
     * A rectangle representing the portion of the map imagery currently in view.
     * A rectangle at X=0, Y=0 with a Height and Width of 1 implies the entire plotting area is in view.  A Height and Width of .5 would imply that the view is halfway zoomed in.
    */
    get windowRect() {
        return fromRect(this.i.windowRect);
    }
    set windowRect(v) {
        this.i.windowRect = toRect(v);
    }
    /**
     * The IgxGeographicMapComponent which is hosting this GeographicMapImagery control.
    */
    get geographicMap() {
        if (this.i.geographicMap == null) {
            return null;
        }
        return this.i.geographicMap.externalObject;
    }
    set geographicMap(v) {
        v == null ? this.i.geographicMap = null : this.i.geographicMap = v.i;
    }
    /**
     * Gets or sets the referer sent in the headers of the tile request.
    */
    get referer() {
        return this.i.referer;
    }
    set referer(v) {
        this.i.referer = v;
    }
    /**
     * Gets or sets the UserAgent sent in the headers of the tile request.
    */
    get userAgent() {
        return this.i.userAgent;
    }
    set userAgent(v) {
        this.i.userAgent = v;
    }
    get opacity() {
        return this.i.opacity;
    }
    set opacity(v) {
        this.i.opacity = +v;
    }
    findByName(name) {
        if (this.geographicMap && this.geographicMap.name && this.geographicMap.name == name) {
            return this.geographicMap;
        }
        return null;
    }
    /**
     * Removes all cached tile Imagery from the
    
    */
    clearTileCache() {
        this.i.clearTileCache();
    }
    /**
     * Event raised when the image tiles have been downloaded.
    */
    get imageTilesReady() {
        return this._imageTilesReady;
    }
    set imageTilesReady(ev) {
        if (this._imageTilesReady_wrapped !== null) {
            this.i.imageTilesReady = delegateRemove(this.i.imageTilesReady, this._imageTilesReady_wrapped);
            this._imageTilesReady_wrapped = null;
            this._imageTilesReady = null;
        }
        this._imageTilesReady = ev;
        this._imageTilesReady_wrapped = (o, e) => {
            let outerArgs = new IgrImageTilesReadyEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeImageTilesReady) {
                this.beforeImageTilesReady(this, outerArgs);
            }
            if (this._imageTilesReady) {
                this._imageTilesReady(this, outerArgs);
            }
        };
        this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, this._imageTilesReady_wrapped);
    }
    /**
     * Event raised when tile images have changed.
    */
    get imagesChanged() {
        return this._imagesChanged;
    }
    set imagesChanged(ev) {
        if (this._imagesChanged_wrapped !== null) {
            this.i.imagesChanged = delegateRemove(this.i.imagesChanged, this._imagesChanged_wrapped);
            this._imagesChanged_wrapped = null;
            this._imagesChanged = null;
        }
        this._imagesChanged = ev;
        this._imagesChanged_wrapped = (o, e) => {
            let outerArgs = new IgrImagesChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeImagesChanged) {
                this.beforeImagesChanged(this, outerArgs);
            }
            if (this._imagesChanged) {
                this._imagesChanged(this, outerArgs);
            }
        };
        this.i.imagesChanged = delegateCombine(this.i.imagesChanged, this._imagesChanged_wrapped);
    }
    /**
     * Event raised when an image is being downloaded.
    */
    get cancellingImage() {
        return this._cancellingImage;
    }
    set cancellingImage(ev) {
        if (this._cancellingImage_wrapped !== null) {
            this.i.cancellingImage = delegateRemove(this.i.cancellingImage, this._cancellingImage_wrapped);
            this._cancellingImage_wrapped = null;
            this._cancellingImage = null;
        }
        this._cancellingImage = ev;
        this._cancellingImage_wrapped = (o, e) => {
            let outerArgs = new IgrCancellingMultiScaleImageEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCancellingImage) {
                this.beforeCancellingImage(this, outerArgs);
            }
            if (this._cancellingImage) {
                this._cancellingImage(this, outerArgs);
            }
        };
        this.i.cancellingImage = delegateCombine(this.i.cancellingImage, this._cancellingImage_wrapped);
    }
    /**
     * Event raised when an image is being downloaded.
    */
    get downloadingImage() {
        return this._downloadingImage;
    }
    set downloadingImage(ev) {
        if (this._downloadingImage_wrapped !== null) {
            this.i.downloadingImage = delegateRemove(this.i.downloadingImage, this._downloadingImage_wrapped);
            this._downloadingImage_wrapped = null;
            this._downloadingImage = null;
        }
        this._downloadingImage = ev;
        this._downloadingImage_wrapped = (o, e) => {
            let outerArgs = new IgrDownloadingMultiScaleImageEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeDownloadingImage) {
                this.beforeDownloadingImage(this, outerArgs);
            }
            if (this._downloadingImage) {
                this._downloadingImage(this, outerArgs);
            }
        };
        this.i.downloadingImage = delegateCombine(this.i.downloadingImage, this._downloadingImage_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let SubDomainsCollection = /*@__PURE__*/ (() => {
    class SubDomainsCollection extends ObservableCollection$1 {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        super(String_$type, 0);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(String_$type, 1, c);
                    }
                    break;
            }
        }
    }
    SubDomainsCollection.$t = /*@__PURE__*/ markType(SubDomainsCollection, 'SubDomainsCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(String_$type));
    return SubDomainsCollection;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BingMapsMapImageryView = /*@__PURE__*/ (() => {
    class BingMapsMapImageryView extends GeographicMapImageryView {
        constructor(a) {
            super(a);
            this.k = a;
        }
        m() {
            if (this.k.subDomains == null) {
                this.k.subDomains = new SubDomainsCollection(0);
            }
            this.k.ap.tilePath = this.k.actualTilePath;
            this.k.ap.subDomains = this.k.actualSubDomains;
            this.k.ap.cultureName = this.k.cultureName;
        }
        o() {
            this.k.ap.tilePath = this.k.actualTilePath;
        }
        l() {
            this.k.ap.cultureName = this.k.cultureName;
        }
        n() {
            this.k.ap.subDomains = this.k.actualSubDomains;
        }
    }
    BingMapsMapImageryView.$t = /*@__PURE__*/ markType(BingMapsMapImageryView, 'BingMapsMapImageryView', GeographicMapImageryView.$);
    return BingMapsMapImageryView;
})();
/**
 * @hidden
 */
let BingMapsMapImagery = /*@__PURE__*/ (() => {
    class BingMapsMapImagery extends GeographicMapImagery {
        constructor() {
            super(new BingMapsTileSource(0));
            this._pendingBingRequest_ = null;
            this._isInitialized = false;
            this.bw = null;
            this.bn = null;
            this.bx = null;
            this.bv = null;
            this.getResponseCompleted = this.getResponseCompleted.bind(this);
            this.bm.m();
            this.actualBingImageryRestUri = BingMapsMapImagery.b9;
        }
        ai() {
            return new BingMapsMapImageryView(this);
        }
        a9(a) {
            super.a9(a);
            this.bm = a;
        }
        get isInitialized() {
            return this._isInitialized;
        }
        set isInitialized(a) {
            this._isInitialized = a;
        }
        get actualTilePath() {
            return this.bw;
        }
        set actualTilePath(a) {
            let b = this.bw;
            this.bw = a;
            this.cj("ActualTilePath", b, this.bw);
        }
        get actualSubDomains() {
            return this.bn;
        }
        set actualSubDomains(a) {
            let b = this.bn;
            this.bn = a;
            this.cj("ActualSubDomains", b, this.bn);
        }
        get bingImageryRestUri() {
            return this.bx;
        }
        set bingImageryRestUri(a) {
            let b = this.bx;
            this.bx = a;
            this.cj("BingImageryRestUri", b, this.bx);
        }
        get actualBingImageryRestUri() {
            return this.bv;
        }
        set actualBingImageryRestUri(a) {
            let b = this.bv;
            this.bv = a;
            this.a8("ActualBingImageryRestUri", b, this.bv);
        }
        requestMapSettings() {
            this.cl(true);
        }
        cl(a) {
            this.ci(a);
        }
        bt() {
            if ((this.tilePath == null) && (this.subDomains == null)) {
                return true;
            }
            return false;
        }
        cn() {
            this.isInitialized = false;
            if (!this.bs()) {
                this.cm("", null);
                return;
            }
            if (!this.isDeferredLoad) {
                this.cl(false);
            }
        }
        bs() {
            if (stringIsNullOrEmpty(this.apiKey) || this.apiKey.length < 20) {
                return false;
            }
            return true;
        }
        cg() {
        }
        cm(a, b) {
            if (a != this.actualTilePath) {
                this.actualTilePath = a;
            }
            let c = b == null ? null : new SubDomainsCollection(1, b);
            if (this.actualSubDomains != c) {
                this.actualSubDomains = c;
            }
            this.bm.m();
        }
        ci(a) {
            if ((!a) && (this.isDeferredLoad)) {
                return;
            }
            if (!this.bs()) {
                this.isInitialized = false;
                this.cm("", null);
                return;
            }
            this.isInitialized = true;
            let b = null;
            if (this.bingImageryRestUri != null) {
                if (Uri.isWellFormedUriString(this.bingImageryRestUri, 1)) {
                    b = this.bingImageryRestUri;
                }
            }
            else {
                if (Uri.isWellFormedUriString(this.actualBingImageryRestUri, 1)) {
                    b = this.actualBingImageryRestUri;
                }
            }
            if (b == null) {
                this.cm("", null);
                return;
            }
            let c = this.imageryStyle;
            b += enumGetBox(BingMapsImageryStyle_$type, c);
            let d = "key=" + this.apiKey + "&include=ImageryProviders";
            let url_ = b + "?" + d;
            this._pendingBingRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted, null);
        }
        getResponseCompleted(a, b) {
            if (b != this._pendingBingRequest_) {
                return;
            }
            this._pendingBingRequest_ = null;
            let data_ = a;
            let resourceSets_ = JSON.parse(data_).resourceSets;
            if (resourceSets_ == null) {
                return;
            }
            let resources_ = resourceSets_.length > 0 ? resourceSets_[0].resources : null;
            if (resources_ == null) {
                return;
            }
            if (resources_.length == 0) {
                return;
            }
            ;
            let imageUrl_ = (resources_[0].imageUrl);
            let subDomains_ = new List$1(String_$type, 0);
            for (var i = 0; i < resources_[0].imageUrlSubdomains.length; i++) {
                subDomains_.add(resources_[0].imageUrlSubdomains[i]);
            }
            ;
            this.cm(imageUrl_, subDomains_);
        }
        cf(a, b) {
            this.aj.e();
            this.cn();
            this.cj(BingMapsMapImagery.$$p[4], this.actualSubDomains, this.actualSubDomains);
        }
        cj(a, b, c) {
            switch (a) {
                case BingMapsMapImagery.$$p[0]:
                    this.cn();
                    break;
                case BingMapsMapImagery.$$p[3]:
                    this.cn();
                    break;
                case BingMapsMapImagery.$$p[5]:
                    this.cg();
                    this.actualTilePath = c;
                    this.bm.o();
                    this.aj.e();
                    break;
                case BingMapsMapImagery.$$p[1]:
                    this.bm.l();
                    this.aj.e();
                    break;
                case BingMapsMapImagery.$$p[2]:
                    this.cn();
                    break;
                case BingMapsMapImagery.$$p[4]:
                    this.cg();
                    let d = b;
                    let e = c;
                    if (this.actualSubDomains != null) {
                        let f = this.actualSubDomains;
                        f.collectionChanged = delegateRemove(f.collectionChanged, runOn(this, this.cf));
                    }
                    this.actualSubDomains = e;
                    if (this.actualSubDomains != null) {
                        e.collectionChanged = delegateCombine(e.collectionChanged, runOn(this, this.cf));
                    }
                    this.bm.n();
                    this.aj.e();
                    break;
                case "ActualTilePath":
                    let g = c;
                    if (stringIsNullOrEmpty(g)) {
                        this.cn();
                    }
                    break;
                case "BingImageryRestUri":
                    this.actualBingImageryRestUri = c;
                    this.cg();
                    this.cn();
                    break;
                case "ActualBingImageryRestUri":
                    this.cg();
                    this.cn();
                    break;
            }
            super.a8(a, b, c);
        }
    }
    BingMapsMapImagery.$t = /*@__PURE__*/ markType(BingMapsMapImagery, 'BingMapsMapImagery', GeographicMapImagery.$);
    BingMapsMapImagery.b9 = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/";
    BingMapsMapImagery.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, BingMapsMapImagery, 'cj', ['ApiKey', [2, /*@__PURE__*/ stringEmpty()], 'CultureName', [2, "en-US"], 'ImageryStyle', [BingMapsImageryStyle_$type, /*@__PURE__*/ enumGetBox(BingMapsImageryStyle_$type, 1)], 'IsDeferredLoad', [0, false], 'SubDomains', [SubDomainsCollection.$, null], 'TilePath', [2, null]]);
    return BingMapsMapImagery;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * UI element class used to display BingMapsMap imagery in the IgxGeographicMap.Component
*/
class IgrBingMapsMapImagery extends IgrGeographicMapImagery {
    constructor() {
        super();
        this._subDomains = null;
        this._actualSubDomains = null;
    }
    createImplementation() {
        return new BingMapsMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets a status whether the Bing Maps service is initialized.
    */
    get isInitialized() {
        return this.i.isInitialized;
    }
    set isInitialized(v) {
        this.i.isInitialized = ensureBool(v);
    }
    /**
     * Gets or sets whether the Bing Maps service should be auto-initialized upon valid property values.
    */
    get isDeferredLoad() {
        return this.i.isDeferredLoad;
    }
    set isDeferredLoad(v) {
        this.i.isDeferredLoad = ensureBool(v);
    }
    /**
     * Gets or sets the map tile image uri.
    */
    get tilePath() {
        return this.i.tilePath;
    }
    set tilePath(v) {
        this.i.tilePath = v;
    }
    /**
     * Gets or sets the actual map tile image uri.
    */
    get actualTilePath() {
        return this.i.actualTilePath;
    }
    set actualTilePath(v) {
        this.i.actualTilePath = v;
    }
    /**
     * Gets or sets the collection of image uri subdomains.
    */
    get subDomains() {
        if (this._subDomains === null) {
            let coll = new IgrSubDomainsCollection();
            let innerColl = this.i.subDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection(0);
            }
            this._subDomains = coll._fromInner(innerColl);
            this.i.subDomains = innerColl;
        }
        return this._subDomains;
    }
    set subDomains(v) {
        if (this._subDomains !== null) {
            this._subDomains._setSyncTarget(null);
            this._subDomains = null;
        }
        let coll = new IgrSubDomainsCollection();
        this._subDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.subDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._subDomains._setSyncTarget(syncColl);
        this.i.subDomains = innerColl;
    }
    /**
     * Gets or sets the actual collection of image uri subdomains.
    */
    get actualSubDomains() {
        if (this._actualSubDomains === null) {
            let coll = new IgrSubDomainsCollection();
            let innerColl = this.i.actualSubDomains;
            if (!innerColl) {
                innerColl = new SubDomainsCollection(0);
            }
            this._actualSubDomains = coll._fromInner(innerColl);
            this.i.actualSubDomains = innerColl;
        }
        return this._actualSubDomains;
    }
    set actualSubDomains(v) {
        if (this._actualSubDomains !== null) {
            this._actualSubDomains._setSyncTarget(null);
            this._actualSubDomains = null;
        }
        let coll = new IgrSubDomainsCollection();
        this._actualSubDomains = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.actualSubDomains;
        if (!innerColl) {
            innerColl = new SubDomainsCollection(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._actualSubDomains._setSyncTarget(syncColl);
        this.i.actualSubDomains = innerColl;
    }
    /**
     * Gets or sets the Bing Imagery Rest Uri.
    */
    get bingImageryRestUri() {
        return this.i.bingImageryRestUri;
    }
    set bingImageryRestUri(v) {
        this.i.bingImageryRestUri = v;
    }
    /**
     * Gets or sets the Actual Bing Imagery Rest Uri.
    */
    get actualBingImageryRestUri() {
        return this.i.actualBingImageryRestUri;
    }
    set actualBingImageryRestUri(v) {
        this.i.actualBingImageryRestUri = v;
    }
    /**
     * Gets or sets the culture name for this tile source.
    */
    get cultureName() {
        return this.i.cultureName;
    }
    set cultureName(v) {
        this.i.cultureName = v;
    }
    /**
     * Gets or sets an API key required by the Bing Maps imagery service.
     * This key must be obtained from the http://www.bingmapsportal.com website.
    */
    get apiKey() {
        return this.i.apiKey;
    }
    set apiKey(v) {
        this.i.apiKey = v;
    }
    /**
     * Gets or sets a map style of the Bing Maps imagery tiles.  For example: Aerial, AerialWithLabels, or Road map style.
    */
    get imageryStyle() {
        return this.i.imageryStyle;
    }
    set imageryStyle(v) {
        this.i.imageryStyle = ensureEnum(BingMapsImageryStyle_$type, v);
    }
    /**
     * Will Connect to the Bing Rest API and retrieve the required TilePath and Subdomains from the service.  This requires a valid API key to already be set.
    
    */
    requestMapSettings() {
        this.i.requestMapSettings();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrBingMapsMapImageryModule {
    static register() {
        TypeRegistrar.registerCons("IgrBingMapsMapImagery", IgrBingMapsMapImagery);
        TypeRegistrar.register("BingMapsMapImagery", BingMapsMapImagery.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * UI element class used to display OpenStreetMap imagery in the IgxGeographicMap.Component
*/
class IgrOpenStreetMapImagery extends IgrGeographicMapImagery {
    createImplementation() {
        return new OpenStreetMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the tile path URL.
    */
    get tilePath() {
        return this.i.tilePath;
    }
    set tilePath(v) {
        this.i.tilePath = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrOpenStreetMapImageryModule {
    static register() {
        TypeRegistrar.registerCons("IgrOpenStreetMapImagery", IgrOpenStreetMapImagery);
        TypeRegistrar.register("OpenStreetMapImagery", OpenStreetMapImagery.$type);
    }
}

/**
 * Represents a CustomMapImagery MapImagery
*/
class IgrCustomMapImagery extends IgrGeographicMapImagery {
    constructor() {
        super();
        this._getTileImageUri = null;
        this._getTileImageUri_wrapped = null;
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Raised when URI for tiles should be provided
    */
    get getTileImageUri() {
        return this._getTileImageUri;
    }
    set getTileImageUri(ev) {
        if (this._getTileImageUri_wrapped !== null) {
            this.i.getTileImageUri = delegateRemove(this.i.getTileImageUri, this._getTileImageUri_wrapped);
            this._getTileImageUri_wrapped = null;
            this._getTileImageUri = null;
        }
        this._getTileImageUri = ev;
        this._getTileImageUri_wrapped = (o, e) => {
            let outerArgs = new IgrGetTileImageUriArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeGetTileImageUri) {
                this.beforeGetTileImageUri(this, outerArgs);
            }
            if (this._getTileImageUri) {
                this._getTileImageUri(this, outerArgs);
            }
        };
        this.i.getTileImageUri = delegateCombine(this.i.getTileImageUri, this._getTileImageUri_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let CustomMapImagery = /*@__PURE__*/ (() => {
    class CustomMapImagery extends GeographicMapImagery {
        constructor(a) {
            super(a);
            this.getTileImageUri = null;
            a.getTileImageUri = delegateCombine(a.getTileImageUri, runOn(this, this.bn));
        }
        bn(a, b) {
            this.bm(b);
        }
        bm(a) {
            if (this.getTileImageUri != null) {
                this.getTileImageUri(this, a);
            }
        }
    }
    CustomMapImagery.$t = /*@__PURE__*/ markType(CustomMapImagery, 'CustomMapImagery', GeographicMapImagery.$);
    return CustomMapImagery;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrCustomMapImageryModule {
    static register() {
        TypeRegistrar.registerCons("IgrCustomMapImagery", IgrCustomMapImagery);
        TypeRegistrar.register("CustomMapImagery", CustomMapImagery.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ArcGISOnlineMapImagery = /*@__PURE__*/ (() => {
    class ArcGISOnlineMapImagery extends GeographicMapImagery {
        constructor() {
            super(new ArcGISOnlineTileSource());
            this.bm = 0;
            this.br = null;
            this.bq = null;
            this._pendingTokenRequest_ = null;
            this._pendingMapServerRequest_ = null;
            this.bq = "localhost";
            this.br = "https://www.arcgis.com/sharing/";
            this.bm = 60;
            this.userToken = null;
            this.getResponseCompleted_MapServerResponse = this.getResponseCompleted_MapServerResponse.bind(this);
            this.getResponseCompleted_TokenResponse = this.getResponseCompleted_TokenResponse.bind(this);
        }
        get mapServerUri() {
            return this.c(ArcGISOnlineMapImagery.mapServerUriProperty);
        }
        set mapServerUri(a) {
            this.h(ArcGISOnlineMapImagery.mapServerUriProperty, a);
        }
        static ca(a, b) {
            a.cc("MapServerUri", b.oldValue, b.newValue);
        }
        get userName() {
            return this.c(ArcGISOnlineMapImagery.userNameProperty);
        }
        set userName(a) {
            this.h(ArcGISOnlineMapImagery.userNameProperty, a);
        }
        static cd(a, b) {
            a.cc("UserName", b.oldValue, b.newValue);
        }
        get password() {
            return this.c(ArcGISOnlineMapImagery.passwordProperty);
        }
        set password(a) {
            this.h(ArcGISOnlineMapImagery.passwordProperty, a);
        }
        static cb(a, b) {
            a.cc("Password", b.oldValue, b.newValue);
        }
        get userToken() {
            return this.c(ArcGISOnlineMapImagery.userTokenProperty);
        }
        set userToken(a) {
            this.h(ArcGISOnlineMapImagery.userTokenProperty, a);
        }
        static ce(a, b) {
            a.cc("UserToken", b.oldValue, b.newValue);
        }
        get isMapPublic() {
            return this.c(ArcGISOnlineMapImagery.isMapPublicProperty);
        }
        set isMapPublic(a) {
            this.h(ArcGISOnlineMapImagery.isMapPublicProperty, a);
        }
        static b9(a, b) {
            a.cc("IsMapPublic", b.oldValue, b.newValue);
        }
        get defaultTokenTimeout() {
            return this.bm;
        }
        set defaultTokenTimeout(a) {
            this.bm = a;
            this.b5(true);
        }
        get tokenGenerationEndPoint() {
            return this.br;
        }
        set tokenGenerationEndPoint(a) {
            this.br = a;
            this.b5(true);
        }
        get refererUri() {
            return this.bq;
        }
        set refererUri(a) {
            this.bq = a;
            this.b5(true);
        }
        acquireNewToken() {
            this.b5(true);
        }
        b6(a) {
            a();
        }
        b5(a) {
            if (stringIsNullOrEmpty(this.userToken) && a == false) {
                this.cf();
                return;
            }
            let b = this.tokenGenerationEndPoint;
            if (stringIsNullOrEmpty(b)) {
                this.userToken = "";
                return;
            }
            if (b.substr(b.length - 1, 1) != "/") {
                b += "/";
            }
            if (stringIsNullOrEmpty(this.refererUri)) {
                this.userToken = "";
                return;
            }
            let c = this.defaultTokenTimeout;
            if (c < 1) {
                c = 1;
            }
            b += stringFormat1(ArcGISOnlineMapImagery.bs, this.userName, this.password, this.refererUri, c);
            if (!Uri.isWellFormedUriString(b, 1)) {
                this.userToken = "";
                return;
            }
            let url_ = b;
            this._pendingTokenRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted_TokenResponse, null);
        }
        cf() {
            if (stringIsNullOrEmpty(this.mapServerUri)) {
                return;
            }
            let a = this.mapServerUri;
            if (a.substr(a.length - 1, 1) == "/") {
                stringRemove(a, a.length - 1, 1);
            }
            if (!this.isMapPublic) {
                if (stringIsNullOrEmpty(this.userToken)) {
                    return;
                }
                a = stringFormat("{0}?f=json&token={1}", a, this.userToken);
            }
            else {
                a = stringFormat("{0}?f=json", a);
            }
            if (!Uri.isWellFormedUriString(a, 1)) {
                return;
            }
            let url_ = a;
            this._pendingMapServerRequest_ = HttpRequestUtil.submit(url_, this.getResponseCompleted_MapServerResponse, null);
        }
        getResponseCompleted_TokenResponse(a, b) {
            if (b != this._pendingTokenRequest_) {
                return;
            }
            this._pendingTokenRequest_ = null;
            let data_ = a;
            let c = (JSON.parse(data_));
            if (c != null) {
                let d = "";
                if (c.token != null) {
                    d = c.token;
                }
                this.userToken = d;
            }
        }
        getResponseCompleted_MapServerResponse(a, b) {
            if (b != this._pendingMapServerRequest_) {
                return;
            }
            this._pendingMapServerRequest_ = null;
            let data_ = a;
            let c = (JSON.parse(data_));
            if ((c != null) && (c.tileInfo != null)) {
                this.ap.levelOfDetail = c.tileInfo.lods.length;
            }
        }
        cc(a, b, c) {
            let d = typeCast(ArcGISOnlineTileSource.$, this.ap);
            switch (a) {
                case "MapServerUri":
                    if (d != null) {
                        d.mapServerUri = typeCast(String_$type, c);
                    }
                    this.cf();
                    break;
                case "UserName":
                case "Password":
                    if (stringIsNullOrEmpty(this.userName) || stringIsNullOrEmpty(this.password)) {
                        return;
                    }
                    this.b5(true);
                    break;
                case "UserToken":
                    this.b6(() => d.userToken = this.userToken);
                    this.cf();
                    break;
                case "IsMapPublic":
                    d.isMapPublic = this.isMapPublic;
                    break;
            }
            super.a8(a, b, c);
        }
    }
    ArcGISOnlineMapImagery.$t = /*@__PURE__*/ markType(ArcGISOnlineMapImagery, 'ArcGISOnlineMapImagery', GeographicMapImagery.$);
    ArcGISOnlineMapImagery.bs = "generateToken?username={0}&password={1}&client=referer&referer={2}&expiration={3}&f=pjson";
    ArcGISOnlineMapImagery.mapServerUriProperty = /*@__PURE__*/ DependencyProperty.i("MapServerUri", String_$type, ArcGISOnlineMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, ArcGISOnlineMapImagery.ca));
    ArcGISOnlineMapImagery.userNameProperty = /*@__PURE__*/ DependencyProperty.i("UserName", String_$type, ArcGISOnlineMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, ArcGISOnlineMapImagery.cd));
    ArcGISOnlineMapImagery.passwordProperty = /*@__PURE__*/ DependencyProperty.i("Password", String_$type, ArcGISOnlineMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, ArcGISOnlineMapImagery.cb));
    ArcGISOnlineMapImagery.userTokenProperty = /*@__PURE__*/ DependencyProperty.i("UserToken", String_$type, ArcGISOnlineMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, null, ArcGISOnlineMapImagery.ce));
    ArcGISOnlineMapImagery.isMapPublicProperty = /*@__PURE__*/ DependencyProperty.i("IsMapPublic", Boolean_$type, ArcGISOnlineMapImagery.$, /*@__PURE__*/ new PropertyMetadata(2, true, ArcGISOnlineMapImagery.b9));
    return ArcGISOnlineMapImagery;
})();

/**
 * UI element class used to display ArcGIS Online Map imagery in the IgxGeographicMap.Component
*/
class IgrArcGISOnlineMapImagery extends IgrGeographicMapImagery {
    createImplementation() {
        return new ArcGISOnlineMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the map tile server uri.
    */
    get mapServerUri() {
        return this.i.mapServerUri;
    }
    set mapServerUri(v) {
        this.i.mapServerUri = v;
    }
    /**
     * Gets or sets the UserName.
    */
    get userName() {
        return this.i.userName;
    }
    set userName(v) {
        this.i.userName = v;
    }
    /**
     * Gets or sets the Password.
    */
    get password() {
        return this.i.password;
    }
    set password(v) {
        this.i.password = v;
    }
    /**
     * Gets or sets the UserToken.
    */
    get userToken() {
        return this.i.userToken;
    }
    set userToken(v) {
        this.i.userToken = v;
    }
    /**
     * Gets or sets the IsMapPublic variable.  A value of false requires authentication parameters.
    */
    get isMapPublic() {
        return this.i.isMapPublic;
    }
    set isMapPublic(v) {
        this.i.isMapPublic = ensureBool(v);
    }
    /**
     * Gets or Sets the Default Token Timeout before the Token Expires, this value is in Minutes
    */
    get defaultTokenTimeout() {
        return this.i.defaultTokenTimeout;
    }
    set defaultTokenTimeout(v) {
        this.i.defaultTokenTimeout = +v;
    }
    /**
     * Gets or Sets the current endpoint to retrieve the token.
    */
    get tokenGenerationEndPoint() {
        return this.i.tokenGenerationEndPoint;
    }
    set tokenGenerationEndPoint(v) {
        this.i.tokenGenerationEndPoint = v;
    }
    /**
     * Contains the User Supplied Referer Uri to be used in Token Generation.
    */
    get refererUri() {
        return this.i.refererUri;
    }
    set refererUri(v) {
        this.i.refererUri = v;
    }
    /**
     * Retreives a new token based on the preconfigured parameters and updates the UserToken field, Normal this is called automatically.
     * The is provided to the end-user to allow them to reteive tokens on their onw.
    
    */
    acquireNewToken() {
        this.i.acquireNewToken();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrArcGISOnlineMapImageryModule {
    static register() {
        TypeRegistrar.registerCons("IgrArcGISOnlineMapImagery", IgrArcGISOnlineMapImagery);
        TypeRegistrar.register("ArcGISOnlineMapImagery", ArcGISOnlineMapImagery.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicMapCoreModule {
    static register() {
        IgrBingMapsMapImageryModule.register();
        IgrOpenStreetMapImageryModule.register();
        IgrCustomMapImageryModule.register();
        IgrArcGISOnlineMapImageryModule.register();
        TypeRegistrar.registerCons('IgrGeographicMap', IgrGeographicMap);
    }
}

/**
 * Base class for hosting chart series in a IgxGeographicMap.Component
*/
class IgrGeographicMapSeriesHost extends IgrSeries {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Checks if this control is geographic coordinate system
    */
    get isGeographic() {
        return this.i.ct;
    }
    /**
     * The minimum scale at which this series becomes visible.
     * The default value for this property is 1.0, which means the series will always be visible.  At a VisibleFromScale setting of 0.0, the series will never be visible.  At a VisibleFromScale setting of 0.5, the series will be visible as long as the map is zoomed in to at least 200%.
    */
    get visibleFromScale() {
        return this.i.l5;
    }
    set visibleFromScale(v) {
        this.i.l5 = +v;
    }
    /**
     * Gets or sets the coercion methods to use when loading data from data sources.
     * Should be specified before setting any member paths, if being used. Setting it later
     * will not cause data to be reimported into the chart.
    */
    get coercionMethods() {
        return this.i.coercionMethods;
    }
    set coercionMethods(v) {
        this.i.coercionMethods = v;
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.fs(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.fp(toPoint(world));
        return (iv);
    }
    /**
     * Renders the series.
    
    * @param animate  * True if the change should be animated.
    */
    renderSeries(animate) {
        this.i.je(animate);
    }
    /**
     * Called when this series' Style is updated.
    
    */
    styleUpdated() {
        this.i.jn();
    }
}

/**
 * Base class for series which render polygons on a map.
*/
class IgrGeographicShapeSeriesBase extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
        this._currData = null;
        this._onImportCompleted = null;
    }
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the string path of the .shp portion of the Shapefile.
    */
    set shapeDataSource(value) {
        this._shapeDataSource = value;
        this.updateShapeDataSource();
    }
    get shapeDataSource() {
        return this._shapeDataSource;
    }
    /**
     * Gets or sets the string path of the .dbf portion of the Shapefile.
    */
    set databaseSource(value) {
        this._databaseSource = value;
        this.updateShapeDataSource();
    }
    get databaseSource() {
        return this._databaseSource;
    }
    onUpdateDataSource(dataSource) {
        if (this._onImportCompleted == null) {
            this._onImportCompleted = (s, e) => {
                if (this._currData) {
                    this._currData.i.importCompleted = delegateRemove(this._currData.i.importCompleted, this._onImportCompleted);
                    var data = this._currData;
                    this._currData = null;
                    this.i.itemsSource = data.getPointData();
                }
            };
        }
        if (dataSource && dataSource.getPointData) {
            if (dataSource.count > 0) {
                return dataSource.getPointData();
            }
            this._currData = dataSource;
            this._currData.i.importCompleted = delegateCombine(this._currData.i.importCompleted, this._onImportCompleted);
            return null;
        }
        return dataSource;
    }
    updateShapeDataSource() {
        if (this._cachedShapeDataSource == null) {
            this._cachedShapeDataSource = new IgrShapeDataSource();
            this.onShapeDataSourceImportCompleted = this.onShapeDataSourceImportCompleted.bind(this);
            this._cachedShapeDataSource.importCompleted = this.onShapeDataSourceImportCompleted;
        }
        this._cachedShapeDataSource.shapefileSource = this._shapeDataSource;
        this._cachedShapeDataSource.databaseSource = this._databaseSource;
        if (this._shapeDataSource && this._databaseSource) {
            this._cachedShapeDataSource.dataBind();
        }
    }
    onShapeDataSourceImportCompleted(s, e) {
        this.dataSource = this._cachedShapeDataSource.getPointData();
    }
    /**
 * The name of the property on ItemsSource items which, for each shape, contains a list of points to be converted to a polygon.
 * To be consistent with the Shapefile technical description, it is expected that each list of points is defined as an IEnumerable of IEnumerable of Point, or in other words, a list of lists of points.
*/
    get shapeMemberPath() {
        return this.i.mi;
    }
    set shapeMemberPath(v) {
        this.i.mi = v;
    }
    /**
     * Set a shapefile datasource to use with the series.
    */
    get shapefileDataSource() {
        if (this.i.md == null) {
            return null;
        }
        if (!this.i.md.externalObject) {
            let e = new IgrShapeDataSource();
            e._implementation = this.i.md;
            this.i.md.externalObject = e;
        }
        return this.i.md.externalObject;
    }
    set shapefileDataSource(v) {
        v == null ? this.i.md = null : this.i.md = v.i;
    }
    /**
     * The resolution at which to filter out shapes in the series.  For example, if the ShapeFilterResolution is set to 3, then elements with a bounding rectangle smaller than 3 X 3 pixels will be filtered out.
     * In the case of GeographicPolylineSeries, the resolution is compared to either dimension, rather than both.  In other words, a polyline will not be filtered if its height or its width exceeds the value of this property.  Whereas with a ShapeSeries, both the height and the width must exceed the value of this property.
    */
    get shapeFilterResolution() {
        return this.i.mf;
    }
    set shapeFilterResolution(v) {
        this.i.mf = +v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.shapefileDataSource && this.shapefileDataSource.name && this.shapefileDataSource.name == name) {
            return this.shapefileDataSource;
        }
        return null;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicShapeSeriesBase = /*@__PURE__*/ (() => {
    class GeographicShapeSeriesBase extends GeographicMapSeriesHost {
        constructor() {
            super(...arguments);
            this.mc = null;
            this.me = false;
        }
        bf() {
            return new GeographicShapeSeriesBaseView(this);
        }
        iv(a) {
            super.iv(a);
            this.mb = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.mb.b3();
                    break;
                case "ActualBrush":
                    this.mb.b1();
                    break;
                case "ActualOutline":
                    this.mb.b2();
                    break;
                case "ShapeMemberPath":
                    this.mb.b5();
                    break;
                case "Thickness":
                    this.mb.b6();
                    break;
                case GeographicShapeSeriesBase.$$p[0]:
                    this.mb.b4();
                    break;
                case "ShapefileDataSource":
                    if (c != null) {
                        let e = c;
                        if (this.me) {
                            e.importCompleted = delegateRemove(e.importCompleted, runOn(this, this.mk));
                        }
                    }
                    if (d != null) {
                        let f = d;
                        if (f.count > 0) {
                            this.ml();
                            break;
                        }
                        this.me = true;
                        f.importCompleted = delegateCombine(f.importCompleted, runOn(this, this.mk));
                    }
                    break;
            }
        }
        mk(a, b) {
            this.ml();
        }
        ml() {
            let sds_ = this.md;
            let ext_ = sds_.externalObject;
            this.itemsSource = (ext_.getPointData());
        }
        get md() {
            return this.mc;
        }
        set md(a) {
            let b = this.mc;
            this.mc = a;
            if (b != this.mc) {
                this.raisePropertyChanged("ShapefileDataSource", b, this.mc);
            }
        }
        get_dq() {
            return true;
        }
        set_dq(a) {
            super.set_dq(a);
        }
    }
    GeographicShapeSeriesBase.$t = /*@__PURE__*/ markType(GeographicShapeSeriesBase, 'GeographicShapeSeriesBase', GeographicMapSeriesHost.$);
    GeographicShapeSeriesBase.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicShapeSeriesBase, 'raisePropertyChanged', ['ShapeFilterResolution:mf:mm', [1, 2], 'ShapeMemberPath:mi:mn', [2, "points"]]);
    return GeographicShapeSeriesBase;
})();
/**
 * @hidden
 */
let GeographicShapeSeriesBaseView = /*@__PURE__*/ (() => {
    class GeographicShapeSeriesBaseView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            super.bv();
            this.b0.l3.mv = this.b0.mi;
            this.b0.l3.k6 = this.b0.k4;
            this.b0.l3.k9 = this.b0.k5;
        }
        b3() {
            let a = this.b0.l3;
            if (this.b0.bs == null) {
                a.l7 = null;
                a.l9 = null;
                return;
            }
            a.l7 = this.b0.bs.nc;
            a.l9 = this.b0.bs.ne;
        }
        b1() {
            this.b0.l3.k6 = this.b0.k4;
        }
        b2() {
            this.b0.l3.k9 = this.b0.k5;
        }
        b5() {
            this.b0.l3.mv = this.b0.mi;
        }
        b6() {
            this.b0.l3.ey = this.b0.ey;
        }
        b4() {
            this.b0.l3.mp = this.b0.mf;
        }
    }
    GeographicShapeSeriesBaseView.$t = /*@__PURE__*/ markType(GeographicShapeSeriesBaseView, 'GeographicShapeSeriesBaseView', HostSeriesView.$);
    return GeographicShapeSeriesBaseView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicShapeSeriesView = /*@__PURE__*/ (() => {
    class GeographicShapeSeriesView extends GeographicShapeSeriesBaseView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b7 = a;
            if (!this.n) {
                this.b7.mi = "points";
            }
        }
        bv() {
            super.bv();
            this.b7.l3.ok = this.b7.nh;
            this.b7.l3.nk = this.b7.mq;
            this.b7.l3.n1 = this.b7.m4;
            this.b7.l3.nm = this.b7.ms;
            this.b7.l3.ne = this.b7.mo;
        }
        cc() {
            this.b7.l3.n1 = this.b7.m4;
        }
        ce() {
            this.b7.l3.nm = this.b7.ms;
        }
        b9() {
            this.b7.l3.ne = this.b7.mo;
        }
        cd() {
            this.b7.l3.nf = this.b7.mp;
        }
        b8() {
            this.b7.l3.og = this.b7.ne;
        }
        ca() {
            this.b7.l3.oh = this.b7.nf;
        }
        cb() {
            this.b7.l3.oj = this.b7.ng;
        }
        cf() {
            this.b7.l3.nk = this.b7.mq;
        }
        cg() {
            this.b7.l3.ok = this.b7.nh;
        }
    }
    GeographicShapeSeriesView.$t = /*@__PURE__*/ markType(GeographicShapeSeriesView, 'GeographicShapeSeriesView', GeographicShapeSeriesBaseView.$);
    return GeographicShapeSeriesView;
})();
/**
 * @hidden
 */
let GeographicShapeSeries = /*@__PURE__*/ (() => {
    class GeographicShapeSeries extends GeographicShapeSeriesBase {
        constructor() {
            super();
            this.styleShape = null;
            this.ab = GeographicShapeSeries.$;
        }
        bf() {
            return new GeographicShapeSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mr = a;
        }
        l2() {
            let a = new ScatterPolygonSeries();
            a.styleShape = delegateCombine(a.styleShape, runOn(this, this.m3));
            return a;
        }
        m3(a, b) {
            if (this.styleShape != null) {
                this.styleShape(this, b);
            }
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case GeographicShapeSeries.$$p[4]:
                    this.mr.cc();
                    break;
                case GeographicShapeSeries.$$p[5]:
                    this.mr.ce();
                    break;
                case GeographicShapeSeries.$$p[1]:
                    this.mr.b9();
                    break;
                case GeographicShapeSeries.$$p[6]:
                    this.mr.cd();
                    break;
                case GeographicShapeSeries.$$p[0]:
                    this.mr.b8();
                    break;
                case GeographicShapeSeries.$$p[2]:
                    this.mr.ca();
                    break;
                case GeographicShapeSeries.$$p[3]:
                    this.mr.cb();
                    break;
                case GeographicShapeSeries.$$p[8]:
                    this.mr.cf();
                    break;
                case GeographicShapeSeries.$$p[7]:
                    this.mr.cg();
                    break;
            }
        }
    }
    GeographicShapeSeries.$t = /*@__PURE__*/ markType(GeographicShapeSeries, 'GeographicShapeSeries', GeographicShapeSeriesBase.$);
    GeographicShapeSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicShapeSeries, 'raisePropertyChanged', ['MarkerBrush:ne:m5', [Brush.$], 'MarkerCollisionAvoidance:mo:m6', [CollisionAvoidanceType_$type, /*@__PURE__*/ enumGetBox(CollisionAvoidanceType_$type, 0)], 'MarkerOutline:nf:m7', [Brush.$], 'MarkerStyle:ng:m8', [Style.$], 'MarkerTemplate:m4:m9', [DataTemplate.$, null], 'MarkerThickness:ms:na', [1, /*@__PURE__*/ DeviceUtils.g(2)], 'MarkerType:mp:nb', [MarkerType_$type, /*@__PURE__*/ enumGetBox(MarkerType_$type, 1)], 'ShapeStyle:nh:nc', [Style.$, null], 'ShapeStyleSelector:mq:nd', [StyleSelector.$, null]]);
    return GeographicShapeSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class which renders polygons as Paths, in a geographic context, based on lists of points in the ItemsSource.
*/
class IgrGeographicShapeSeries extends IgrGeographicShapeSeriesBase {
    constructor(props) {
        super(props);
        this._styleShape = null;
        this._styleShape_wrapped = null;
    }
    createImplementation() {
        return new GeographicShapeSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the fill brush.
    */
    get shapeFill() {
        return this.i.nh ? this.i.nh.fill : null;
    }
    set shapeFill(v) {
        this.ensureShapeStyle();
        this.i.nh.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get shapeStroke() {
        return this.i.nh ? this.i.nh.stroke : null;
    }
    set shapeStroke(v) {
        this.ensureShapeStyle();
        this.i.nh.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get shapeStrokeThickness() {
        return this.i.nh ? this.i.nh.strokeThickness : NaN;
    }
    set shapeStrokeThickness(v) {
        this.ensureShapeStyle();
        this.i.nh.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get shapeOpacity() {
        return this.i.nh ? this.i.nh.opacity : NaN;
    }
    set shapeOpacity(v) {
        this.ensureShapeStyle();
        this.i.nh.opacity = +v;
    }
    ensureShapeStyle() {
        if (this.i.nh) {
            return;
        }
        this.i.nh = new Style();
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.mp;
    }
    set markerType(v) {
        this.i.mp = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.m4;
    }
    set markerTemplate(v) {
        this.i.m4 = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.ne);
    }
    set markerBrush(v) {
        this.i.ne = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.nf);
    }
    set markerOutline(v) {
        this.i.nf = stringToBrush(v);
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.ms;
    }
    set markerThickness(v) {
        this.i.ms = +v;
    }
    /**
     * The desired behavior for markers in this series which are placed too close together for the current view, resulting in a collision.
    */
    get markerCollisionAvoidance() {
        return this.i.mo;
    }
    set markerCollisionAvoidance(v) {
        this.i.mo = ensureEnum(CollisionAvoidanceType_$type, v);
    }
    get styleShape() {
        return this._styleShape;
    }
    set styleShape(ev) {
        if (this._styleShape_wrapped !== null) {
            this.i.styleShape = delegateRemove(this.i.styleShape, this._styleShape_wrapped);
            this._styleShape_wrapped = null;
            this._styleShape = null;
        }
        this._styleShape = ev;
        this._styleShape_wrapped = (o, e) => {
            let outerArgs = new IgrStyleShapeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeStyleShape) {
                this.beforeStyleShape(this, outerArgs);
            }
            if (this._styleShape) {
                this._styleShape(this, outerArgs);
            }
        };
        this.i.styleShape = delegateCombine(this.i.styleShape, this._styleShape_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicShapeSeriesModule {
    static register() {
        IgrScatterPolygonSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicShapeSeries", IgrGeographicShapeSeries);
        TypeRegistrar.register("GeographicShapeSeries", GeographicShapeSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicPolylineSeriesView = /*@__PURE__*/ (() => {
    class GeographicPolylineSeriesView extends GeographicShapeSeriesBaseView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b7 = a;
        }
        bv() {
            super.bv();
            this.b7.l3.nd = this.b7.mo;
            this.b7.l3.ni = this.b7.mw;
        }
        b8() {
            this.b7.l3.nd = this.b7.mo;
        }
        b9() {
            this.b7.l3.ni = this.b7.mw;
        }
    }
    GeographicPolylineSeriesView.$t = /*@__PURE__*/ markType(GeographicPolylineSeriesView, 'GeographicPolylineSeriesView', GeographicShapeSeriesBaseView.$);
    return GeographicPolylineSeriesView;
})();
/**
 * @hidden
 */
let GeographicPolylineSeries = /*@__PURE__*/ (() => {
    class GeographicPolylineSeries extends GeographicShapeSeriesBase {
        constructor() {
            super();
            this.styleShape = null;
            this.ab = GeographicPolylineSeries.$;
        }
        bf() {
            return new GeographicPolylineSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mp = a;
        }
        l2() {
            let a = new ScatterPolylineSeries();
            a.styleShape = delegateCombine(a.styleShape, runOn(this, this.mt));
            return a;
        }
        mt(a, b) {
            if (this.styleShape != null) {
                this.styleShape(this, b);
            }
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case GeographicPolylineSeries.$$p[1]:
                    this.mp.b8();
                    break;
                case GeographicPolylineSeries.$$p[0]:
                    this.mp.b9();
                    break;
            }
        }
    }
    GeographicPolylineSeries.$t = /*@__PURE__*/ markType(GeographicPolylineSeries, 'GeographicPolylineSeries', GeographicShapeSeriesBase.$);
    GeographicPolylineSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicPolylineSeries, 'raisePropertyChanged', ['ShapeStyle:mw:mu', [Style.$, null], 'ShapeStyleSelector:mo:mv', [StyleSelector.$, null]]);
    return GeographicPolylineSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class used for displaying multiple polylines, in a geographic context, for datasources which contain multiple lists of points.
*/
class IgrGeographicPolylineSeries extends IgrGeographicShapeSeriesBase {
    constructor(props) {
        super(props);
        this._styleShape = null;
        this._styleShape_wrapped = null;
    }
    createImplementation() {
        return new GeographicPolylineSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the fill brush.
    */
    get shapeFill() {
        return this.i.mw ? this.i.mw.fill : null;
    }
    set shapeFill(v) {
        this.ensureShapeStyle();
        this.i.mw.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get shapeStroke() {
        return this.i.mw ? this.i.mw.stroke : null;
    }
    set shapeStroke(v) {
        this.ensureShapeStyle();
        this.i.mw.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get shapeStrokeThickness() {
        return this.i.mw ? this.i.mw.strokeThickness : NaN;
    }
    set shapeStrokeThickness(v) {
        this.ensureShapeStyle();
        this.i.mw.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get shapeOpacity() {
        return this.i.mw ? this.i.mw.opacity : NaN;
    }
    set shapeOpacity(v) {
        this.ensureShapeStyle();
        this.i.mw.opacity = +v;
    }
    ensureShapeStyle() {
        if (this.i.mw) {
            return;
        }
        this.i.mw = new Style();
    }
    get styleShape() {
        return this._styleShape;
    }
    set styleShape(ev) {
        if (this._styleShape_wrapped !== null) {
            this.i.styleShape = delegateRemove(this.i.styleShape, this._styleShape_wrapped);
            this._styleShape_wrapped = null;
            this._styleShape = null;
        }
        this._styleShape = ev;
        this._styleShape_wrapped = (o, e) => {
            let outerArgs = new IgrStyleShapeEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeStyleShape) {
                this.beforeStyleShape(this, outerArgs);
            }
            if (this._styleShape) {
                this._styleShape(this, outerArgs);
            }
        };
        this.i.styleShape = delegateCombine(this.i.styleShape, this._styleShape_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicPolylineSeriesModule {
    static register() {
        IgrScatterPolylineSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicPolylineSeries", IgrGeographicPolylineSeries);
        TypeRegistrar.register("GeographicPolylineSeries", GeographicPolylineSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TileGeneratorMapImagery = /*@__PURE__*/ (() => {
    class TileGeneratorMapImagery extends GeographicMapImagery {
        constructor() {
            super(new TileGeneratorTileSource());
            this.downloadingImage = delegateCombine(this.downloadingImage, runOn(this, this.bo));
            this.cancellingImage = delegateCombine(this.cancellingImage, runOn(this, this.bn));
        }
        bn(a, b) {
            let c = b.uri.toString().split('/');
            let d = parseInt(stringReplace(c[3], "/", ""));
            let e = parseInt(stringReplace(c[4], "/", ""));
            let f = parseInt(stringReplace(stringReplace(c[5], "/", ""), ".png", ""));
            if (this.tileGenerator != null) {
                this.tileGenerator.cancelTile(d, e, f);
            }
        }
        bo(a, b) {
            let c = b.uri.toString().split('/');
            let d = parseInt(stringReplace(c[3], "/", ""));
            let e = parseInt(stringReplace(c[4], "/", ""));
            let f = parseInt(stringReplace(stringReplace(c[5], "/", ""), ".png", ""));
            b.uri = null;
            let img_ = b.image;
            if (this.tileGenerator != null) {
                this.tileGenerator.getTile(d, e, f, (g, h) => this.deferralHandler.deferAction(() => img_.src = h.url), (g, h) => {
                }, (g, h) => {
                }, img_);
            }
        }
    }
    TileGeneratorMapImagery.$t = /*@__PURE__*/ markType(TileGeneratorMapImagery, 'TileGeneratorMapImagery', GeographicMapImagery.$);
    TileGeneratorMapImagery.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, TileGeneratorMapImagery, 'a8', ['TileGenerator', [ITileGenerator_$type, null]]);
    return TileGeneratorMapImagery;
})();

/**
 * Represents a CustomMapImagery MapImagery
*/
class IgrTileGeneratorMapImagery extends IgrGeographicMapImagery {
    createImplementation() {
        return new TileGeneratorMapImagery();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor() {
        super();
    }
    /**
     * Gets or sets the culture name for this tile source.
    */
    get tileGenerator() {
        return this.i.tileGenerator;
    }
    set tileGenerator(v) {
        this.i.tileGenerator = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTileGeneratorMapImageryModule {
    static register() {
        TypeRegistrar.registerCons("IgrTileGeneratorMapImagery", IgrTileGeneratorMapImagery);
        TypeRegistrar.register("TileGeneratorMapImagery", TileGeneratorMapImagery.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TileSeries = /*@__PURE__*/ (() => {
    class TileSeries extends ShapeSeriesBase {
        constructor() {
            super(...arguments);
            this.ne = null;
            this.nd = null;
            this.imageTilesReady = null;
            this.nh = null;
            this.ni = false;
        }
        bf() {
            return new TileSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.nc = a;
        }
        get_mi() {
            return false;
        }
        get ng() {
            return this.ne;
        }
        set ng(a) {
            let b = a != this.ng;
            if (b) {
                let c = this.ng;
                this.ne = a;
                this.raisePropertyChanged("TileImagery", c, a);
            }
        }
        get nf() {
            return this.nd;
        }
        set nf(a) {
            let b = this.nd;
            this.nd = a;
            this.raisePropertyChanged("ActualTileImagery", b, this.nd);
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            let e;
            let f;
            switch (b) {
                case "TileImagery":
                    e = c;
                    f = d;
                    if (e != null) {
                        e.propertyChanged = delegateRemove(e.propertyChanged, runOn(this, this.nl));
                    }
                    if (f != null) {
                        f.propertyChanged = delegateCombine(f.propertyChanged, runOn(this, this.nl));
                    }
                    this.nc.c5(e, f);
                    this.je(false);
                    this.il();
                    break;
                case "ActualTileImagery":
                    e = c;
                    f = d;
                    if (e != null) {
                        e.imageTilesReady = delegateRemove(e.imageTilesReady, runOn(this, this.nm));
                        e.deferralHandler = null;
                    }
                    if (f != null) {
                        f.imageTilesReady = delegateCombine(f.imageTilesReady, runOn(this, this.nm));
                        f.deferralHandler = this;
                    }
                    this.nc.c4(e, f);
                    if (f != null && typeCast(XamGeographicMap.$, this.bs) !== null) {
                        f.geographicMap = this.bs;
                        this.no(this.bi);
                        this.nc.c1(this.bs.mr);
                    }
                    this.il();
                    break;
                case "ActualWindowRect":
                    this.nc.c1(d);
                    break;
                case "WorldRect":
                    this.nc.c8(d);
                    break;
                case "SeriesViewer":
                    let g = c;
                    let h = d;
                    if (g != null && this.nf != null) {
                        this.nf.bc(null);
                    }
                    if (h != null && this.nf != null) {
                        this.nf.bc(this.bi.t);
                    }
                    break;
            }
        }
        nl(a, b) {
            if (b.propertyName == "MultiScaleImage") {
                this.no(this.bi);
            }
        }
        nm(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new EventArgs());
            }
            if (!this.ni) {
                this.nc.c6();
            }
        }
        register(a, b) {
            this.nh = b;
        }
        unRegister(a) {
            this.nh = null;
        }
        deferredRefresh() {
            this.je(false);
        }
        deferAction(a) {
            if (this.e4 != null) {
                this.e4.setTimeout(a, 0);
            }
            else {
                window.setTimeout(a, 0);
            }
        }
        jt(a, b) {
            this.nc.c7();
            super.jt(a, b);
        }
        jf(a) {
            super.jf(a);
            this.nn(a, this.bi);
        }
        nn(a, b) {
            let c;
            let d;
            let e = b;
            let f = b.getViewInfo(c, d);
            c = f.p0;
            d = f.p1;
            this.no(b);
            if (this.nh != null) {
                this.ni = true;
                this.nh(a);
                this.ni = false;
            }
            e.c6();
        }
        jd(a, b, c, d, e) {
            super.jd(a, b, c, d, e);
            let f = this.dz.item(d);
            f.ay(c);
            if (this.cc(f)) {
                return;
            }
            this.m1(f);
        }
        no(a) {
            let b;
            let c;
            let d = a.getViewInfo(b, c);
            b = d.p0;
            c = d.p1;
            if (this.ng != null && this.ng.ao != null) {
                if (this.ng != this.nf) {
                    this.nf = this.ng;
                }
                if (this.nf != null && !b.isEmpty) {
                    if (this.nf.width != b.width) {
                        this.nf.width = b.width;
                    }
                    if (this.nf.height != b.height) {
                        this.nf.height = b.height;
                    }
                }
            }
        }
        hw(a, b) {
            super.hw(a, b);
            b.c2();
        }
    }
    TileSeries.$t = /*@__PURE__*/ markType(TileSeries, 'TileSeries', ShapeSeriesBase.$, [IMapRenderDeferralHandler_$type]);
    return TileSeries;
})();
/**
 * @hidden
 */
let TileSeriesView = /*@__PURE__*/ (() => {
    class TileSeriesView extends ShapeSeriesViewBase {
        constructor(a) {
            super(a);
            this.cy = null;
            this.c9 = new GeometryGroup();
            this.c0 = null;
            this.cz = null;
            this.cy = a;
        }
        ca(a, b) {
            if (b.c.count > 0) {
                this.c9.d.add(b);
            }
        }
        cu(a, b) {
            return this.cv(a, b, true);
        }
        ct(a, b) {
            return null;
        }
        ce(a) {
        }
        cc(a, b) {
        }
        cj() {
            super.cj();
            this.c9.d.clear();
        }
        ci() {
            super.ci();
            this.an();
        }
        c1(a) {
            if (this.cy.ng != null) {
                this.cy.ng.windowRect = a;
            }
        }
        c4(a, b) {
            if (this.c0 == null) {
                this.c0 = this.e.e4.createElement("canvas");
                let c = this.e.e4.get2DCanvasContext(this.c0);
                this.cz = new RenderingContext(new CanvasViewRenderer(), c);
                this.c0.setAttribute("width", this.br.width.toString());
                this.c0.setAttribute("height", this.br.height.toString());
            }
            if (a != null) {
                a.bb(null);
                a.bc(null);
                a.imagesChanged = delegateRemove(a.imagesChanged, runOn(this, this.c3));
            }
            if (b != null) {
                if (this.t != null) {
                    b.bc(this.t);
                }
                b.bb(this.cz);
                b.bd(this.br);
                b.imagesChanged = delegateCombine(b.imagesChanged, runOn(this, this.c3));
            }
        }
        c3(a, b) {
            this.an();
        }
        c5(a, b) {
        }
        c7() {
            if (this.c0 != null) {
                this.c0.setAttribute("width", this.br.width.toString());
                this.c0.setAttribute("height", this.br.height.toString());
            }
            if (this.cy.ng != null) {
                this.cy.ng.bd(this.br);
            }
        }
        a3(a, b) {
            super.a3(a, b);
            if (b) {
                return;
            }
            if (this.c0 == null) {
                return;
            }
            let c = false;
            if (this.c9.d.count > 0) {
                c = true;
                this.h.z();
                this.h.q(this.c9);
                let d = this.h.g();
                d.clip();
            }
            let e = truncate(Math.round(this.br.left));
            let f = truncate(Math.round(this.br.top));
            let g = truncate(Math.round(this.br.width));
            let h = truncate(Math.round(this.br.height));
            this.h.n(this.c0.getNativeElement(), 1, e, f, g, h, e, f, g, h);
            if (c) {
                this.h.y();
            }
        }
        c6() {
            this.an();
        }
        c2() {
        }
        c8(a) {
            if (this.cy.ng != null) {
                this.cy.ng.a4();
            }
        }
    }
    TileSeriesView.$t = /*@__PURE__*/ markType(TileSeriesView, 'TileSeriesView', ShapeSeriesViewBase.$);
    return TileSeriesView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Represents a tile series class that can render imagery tiles
*/
class IgrTileSeries extends IgrShapeSeriesBase {
    createImplementation() {
        return new TileSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    /**
     * The MapImagery which is used to provide the tiles for display.
    */
    get tileImagery() {
        if (this.i.ng == null) {
            return null;
        }
        return this.i.ng.externalObject;
    }
    set tileImagery(v) {
        v == null ? this.i.ng = null : this.i.ng = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.tileImagery && this.tileImagery.name && this.tileImagery.name == name) {
            return this.tileImagery;
        }
        return null;
    }
    /**
     * Defers rendering of the series
    
    */
    deferredRefresh() {
        this.i.deferredRefresh();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrTileSeriesModule {
    static register() {
        TypeRegistrar.registerCons("IgrTileSeries", IgrTileSeries);
        TypeRegistrar.register("TileSeries", TileSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicTileSeries = /*@__PURE__*/ (() => {
    class GeographicTileSeries extends GeographicShapeSeriesBase {
        constructor() {
            super();
            this.mp = null;
            this.mo = null;
            this.imageTilesReady = null;
            this.ab = GeographicTileSeries.$;
        }
        get mq() {
            return this.mp;
        }
        set mq(a) {
            let b = a != this.mq;
            if (b) {
                let c = this.mq;
                this.mp = a;
                this.raisePropertyChanged("TileImagery", c, a);
            }
        }
        mu() {
            if (this.mq != null) {
                this.mq.clearTileCache();
            }
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "TileImagery":
                    if (this.l3 != null) {
                        this.l3.ng = this.mq;
                    }
                    break;
            }
        }
        l8() {
            super.l8();
            this.l3.ng = this.mq;
            if (this.mo != null) {
                let a = this.mo;
                a.imageTilesReady = delegateRemove(a.imageTilesReady, runOn(this, this.mt));
            }
            this.mo = this.l3;
            if (this.mo != null) {
                let b = this.mo;
                b.imageTilesReady = delegateCombine(b.imageTilesReady, runOn(this, this.mt));
            }
        }
        l2() {
            return new TileSeries();
        }
        mt(a, b) {
            if (this.imageTilesReady != null) {
                this.imageTilesReady(this, new ImageTilesReadyEventArgs());
            }
        }
    }
    GeographicTileSeries.$t = /*@__PURE__*/ markType(GeographicTileSeries, 'GeographicTileSeries', GeographicShapeSeriesBase.$);
    return GeographicTileSeries;
})();

/**
 * Series class used for displaying a tile set, and using shapes to define the areas that should be rendered.
*/
class IgrGeographicTileSeries extends IgrGeographicShapeSeriesBase {
    constructor(props) {
        super(props);
        this._imageTilesReady = null;
        this._imageTilesReady_wrapped = null;
    }
    createImplementation() {
        return new GeographicTileSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The MapImagery which is used to provide the tiles for display.
    */
    get tileImagery() {
        if (this.i.mq == null) {
            return null;
        }
        return this.i.mq.externalObject;
    }
    set tileImagery(v) {
        v == null ? this.i.mq = null : this.i.mq = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.tileImagery && this.tileImagery.name && this.tileImagery.name == name) {
            return this.tileImagery;
        }
        return null;
    }
    /**
     * Removes all cached tile Imagery from the
    
    */
    clearTileCache() {
        this.i.mu();
    }
    /**
     * This event is fired whenever the image tiles transition from a loading state (e.g. some are fading in) to a loaded state.
    */
    get imageTilesReady() {
        return this._imageTilesReady;
    }
    set imageTilesReady(ev) {
        if (this._imageTilesReady_wrapped !== null) {
            this.i.imageTilesReady = delegateRemove(this.i.imageTilesReady, this._imageTilesReady_wrapped);
            this._imageTilesReady_wrapped = null;
            this._imageTilesReady = null;
        }
        this._imageTilesReady = ev;
        this._imageTilesReady_wrapped = (o, e) => {
            let outerArgs = new IgrImageTilesReadyEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeImageTilesReady) {
                this.beforeImageTilesReady(this, outerArgs);
            }
            if (this._imageTilesReady) {
                this._imageTilesReady(this, outerArgs);
            }
        };
        this.i.imageTilesReady = delegateCombine(this.i.imageTilesReady, this._imageTilesReady_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicTileSeriesModule {
    static register() {
        IgrTileSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicTileSeries", IgrGeographicTileSeries);
        TypeRegistrar.register("GeographicTileSeries", GeographicTileSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicProportionalSymbolSeriesView = /*@__PURE__*/ (() => {
    class GeographicProportionalSymbolSeriesView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            super.bv();
            let a = this.b0.l3;
            a.nv = this.b0.mv;
            a.nz = this.b0.mt;
            a.l2 = this.b0.md;
            a.mn = this.b0.na;
            a.l7 = this.b0.ml;
            a.px = this.b0.m6;
            a.o5 = this.b0.me;
            a.pr = this.b0.mr;
            a.pm = this.b0.mn;
            a.o1 = this.b0.mb;
            a.pd = this.b0.mg;
            a.pe = this.b0.mh;
            a.pk = this.b0.mk;
            a.pj = this.b0.mj;
        }
        b9() {
            this.b0.l3.nv = this.b0.mv;
        }
        b8() {
            this.b0.l3.nz = this.b0.mt;
        }
        ce() {
            this.b0.l3.l2 = this.b0.md;
        }
        cc() {
            this.b0.l3.mn = this.b0.na;
        }
        cd() {
            this.b0.l3.l7 = this.b0.ml;
        }
        cf() {
            this.b0.l3.no = this.b0.mm;
        }
        ch() {
            this.b0.l3.xAxis = this.b0.bs.nc;
        }
        ci() {
            this.b0.l3.yAxis = this.b0.bs.ne;
        }
        cg() {
            let a = this.b0.l3;
            if (this.b0.bs == null) {
                a.xAxis = null;
                a.yAxis = null;
                return;
            }
            a.xAxis = this.b0.bs.nc;
            a.yAxis = this.b0.bs.ne;
        }
        ca() {
            this.b0.l3.m1 = this.b0.nt;
        }
        cb() {
            this.b0.l3.m2 = this.b0.nu;
        }
        cj() {
            this.b0.l3.px = this.b0.m6;
        }
        ck() {
            this.b0.l3.o5 = this.b0.me;
            this.b0.l3.pf = this.b0.mi;
        }
        b4() {
            this.b0.l3.pr = this.b0.mr;
        }
        b2() {
            this.b0.l3.o1 = this.b0.mb;
            this.b0.l3.pd = this.b0.mg;
            this.b0.l3.pe = this.b0.mh;
            this.b0.l3.pk = this.b0.mk;
            this.b0.l3.pj = this.b0.mj;
        }
        b1() {
            this.b0.l3.pm = this.b0.mn;
        }
        cl() {
            this.b0.l3.pf = this.b0.mi;
        }
        b3() {
            this.b0.l3.pd = this.b0.mg;
        }
        b7() {
            this.b0.l3.pe = this.b0.mh;
        }
        b6() {
            this.b0.l3.pk = this.b0.mk;
        }
        b5() {
            this.b0.l3.pj = this.b0.mj;
        }
    }
    GeographicProportionalSymbolSeriesView.$t = /*@__PURE__*/ markType(GeographicProportionalSymbolSeriesView, 'GeographicProportionalSymbolSeriesView', HostSeriesView.$);
    return GeographicProportionalSymbolSeriesView;
})();
/**
 * @hidden
 */
let GeographicProportionalSymbolSeries = /*@__PURE__*/ (() => {
    class GeographicProportionalSymbolSeries extends GeographicMapSeriesHost {
        constructor() {
            super();
            this.mc = null;
            this.mh = false;
            this.mk = NaN;
            this.mj = NaN;
            this.ab = GeographicProportionalSymbolSeries.$;
        }
        bf() {
            return new GeographicProportionalSymbolSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mf = a;
        }
        l2() {
            return new BubbleSeries();
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.mf.cg();
                    break;
                case GeographicProportionalSymbolSeries.$$p[5]:
                    this.mf.b9();
                    break;
                case GeographicProportionalSymbolSeries.$$p[4]:
                    this.mf.b8();
                    break;
                case GeographicProportionalSymbolSeries.$$p[13]:
                    this.mf.ce();
                    break;
                case GeographicProportionalSymbolSeries.$$p[11]:
                    this.mf.cc();
                    break;
                case GeographicProportionalSymbolSeries.$$p[12]:
                    this.mf.cd();
                    break;
                case GeographicProportionalSymbolSeries.$$p[14]:
                    this.mf.cf();
                    break;
                case "XAxis":
                    this.mf.ch();
                    break;
                case "YAxis":
                    this.mf.ci();
                    break;
                case GeographicProportionalSymbolSeries.$$p[7]:
                    this.mf.ca();
                    break;
                case GeographicProportionalSymbolSeries.$$p[9]:
                    this.mf.cb();
                    break;
                case GeographicProportionalSymbolSeries.$$p[15]:
                    this.mf.cj();
                    break;
                case GeographicProportionalSymbolSeries.$$p[16]:
                    this.mf.ck();
                    break;
                case GeographicProportionalSymbolSeries.$$p[17]:
                    this.mf.cl();
                    break;
                case GeographicProportionalSymbolSeries.$$p[3]:
                    this.mf.b4();
                    break;
                case GeographicProportionalSymbolSeries.$$p[0]:
                    this.mf.b1();
                    break;
                case GeographicProportionalSymbolSeries.$$p[1]:
                    this.mf.b2();
                    break;
                case GeographicProportionalSymbolSeries.$$p[2]:
                    this.mf.b3();
                    break;
                case GeographicProportionalSymbolSeries.$$p[10]:
                    this.mf.b7();
                    break;
                case GeographicProportionalSymbolSeries.$$p[8]:
                    this.mf.b6();
                    break;
                case GeographicProportionalSymbolSeries.$$p[6]:
                    this.mf.b5();
                    break;
            }
        }
    }
    GeographicProportionalSymbolSeries.$t = /*@__PURE__*/ markType(GeographicProportionalSymbolSeries, 'GeographicProportionalSymbolSeries', GeographicMapSeriesHost.$);
    GeographicProportionalSymbolSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicProportionalSymbolSeries, 'raisePropertyChanged', ['FillMemberPath:mn:nb', [2], 'FillScale:mb:nc', [BrushScale.$], 'FillScaleUseGlobalValues:mg:nd', [0], 'LabelMemberPath:mr:ne', [2], 'LatitudeMemberPath:mt:nf', [2, null], 'LongitudeMemberPath:mv:ng', [2, null], 'MarkerBrushBrightness:mj:nh', [1], 'MarkerBrush:nt:ni', [Brush.$], 'MarkerOutlineBrightness:mk:nj', [1], 'MarkerOutline:nu:nk', [Brush.$], 'MarkerOutlineUsesFillScale:mh:nl', [0], 'MarkerTemplate:na:nm', [DataTemplate.$, null], 'MarkerThickness:ml:nn', [1, /*@__PURE__*/ DeviceUtils.g(2)], 'MarkerType:md:no', [MarkerType_$type, /*@__PURE__*/ enumGetBox(MarkerType_$type, 1)], 'MaximumMarkers:mm:np', [1, 400], 'RadiusMemberPath:m6:nq', [2, null], 'RadiusScale:me:nr', [SizeScale.$], 'RadiusScaleUseGlobalValues:mi:ns', [0]]);
    return GeographicProportionalSymbolSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a ScatterSeries.
*/
class IgrGeographicProportionalSymbolSeries extends IgrGeographicMapSeriesHost {
    createImplementation() {
        return new GeographicProportionalSymbolSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mt;
    }
    set latitudeMemberPath(v) {
        this.i.mt = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.mv;
    }
    set longitudeMemberPath(v) {
        this.i.mv = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.md;
    }
    set markerType(v) {
        this.i.md = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.na;
    }
    set markerTemplate(v) {
        this.i.na = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.nt);
    }
    set markerBrush(v) {
        this.i.nt = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.nu);
    }
    set markerOutline(v) {
        this.i.nu = stringToBrush(v);
    }
    /**
     * Gets or sets the maximum number of markerItems displayed by the current series.
     * If more than the specified number of markerItems are visible, the series will automatically
     * choose a representative set.
    */
    get maximumMarkers() {
        return this.i.mm;
    }
    set maximumMarkers(v) {
        this.i.mm = +v;
    }
    /**
     * Gets or sets the radius mapping property for the current series object.
    */
    get radiusMemberPath() {
        return this.i.m6;
    }
    set radiusMemberPath(v) {
        this.i.m6 = v;
    }
    /**
     * Gets or sets the radius size scale for the bubbles.
    */
    get radiusScale() {
        if (this.i.me == null) {
            return null;
        }
        if (!this.i.me.externalObject) {
            let e = IgrSizeScale._createFromInternal(this.i.me);
            if (e) {
                e._implementation = this.i.me;
            }
            this.i.me.externalObject = e;
        }
        return this.i.me.externalObject;
    }
    set radiusScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.me = null : this.i.me = v.i;
    }
    /**
     * Gets or sets the Label mapping property for the current series object.
    */
    get labelMemberPath() {
        return this.i.mr;
    }
    set labelMemberPath(v) {
        this.i.mr = v;
    }
    /**
     * Gets or sets the fill mapping property for the current series object.
    */
    get fillMemberPath() {
        return this.i.mn;
    }
    set fillMemberPath(v) {
        this.i.mn = v;
    }
    /**
     * Gets or sets the brush scale for the marker brush.
    */
    get fillScale() {
        if (this.i.mb == null) {
            return null;
        }
        if (!this.i.mb.externalObject) {
            let e = IgrBrushScale._createFromInternal(this.i.mb);
            if (e) {
                e._implementation = this.i.mb;
            }
            this.i.mb.externalObject = e;
        }
        return this.i.mb.externalObject;
    }
    set fillScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mb = null : this.i.mb = v.i;
    }
    /**
     * Gets or sets the whether or not the FillScale uses global values of FillMemberPath of multiple series.
     * This setting applies only if multiple series are using the same FillScale.
    */
    get fillScaleUseGlobalValues() {
        return this.i.mg;
    }
    set fillScaleUseGlobalValues(v) {
        this.i.mg = ensureBool(v);
    }
    /**
     * Gets or sets whether or not the marker outline should use FillScale like the marker fill does.
     * This setting applies only if the current series has a FillScale set and it overrides MarkerOutline setting.
    */
    get markerOutlineUsesFillScale() {
        return this.i.mh;
    }
    set markerOutlineUsesFillScale(v) {
        this.i.mh = ensureBool(v);
    }
    /**
     * Gets or sets brightness of the marker outline. Using negative value will change marker outline to darker color and positive value will change marker outline to brighter color
     * Note you can use any values between minimum value of -1 (darkest outline) and maximum value of 1 (brightest outline)
    */
    get markerOutlineBrightness() {
        return this.i.mk;
    }
    set markerOutlineBrightness(v) {
        this.i.mk = +v;
    }
    /**
     * Gets or sets brightness of the marker fill. Using negative value will change marker fill to darker color and positive value will change marker fill to brighter color
     * Note you can use any values between minimum value of -1 (darkest fill) and maximum value of 1 (brightest fill)
    */
    get markerBrushBrightness() {
        return this.i.mj;
    }
    set markerBrushBrightness(v) {
        this.i.mj = +v;
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.ml;
    }
    set markerThickness(v) {
        this.i.ml = +v;
    }
    /**
     * Gets or sets the whether or not the RadiusScale uses global values of RadiusMemberPath of multiple series.
     * This setting applies only if multiple series are using the same RadiusScale.
    */
    get radiusScaleUseGlobalValues() {
        return this.i.mi;
    }
    set radiusScaleUseGlobalValues(v) {
        this.i.mi = ensureBool(v);
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.radiusScale && this.radiusScale.name && this.radiusScale.name == name) {
            return this.radiusScale;
        }
        if (this.fillScale && this.fillScale.name && this.fillScale.name == name) {
            return this.fillScale;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.radiusScale && this.radiusScale._styling) {
            this.radiusScale._styling(container, component, this);
        }
        if (this.fillScale && this.fillScale._styling) {
            this.fillScale._styling(container, component, this);
        }
        this._inStyling = false;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicProportionalSymbolSeriesModule {
    static register() {
        IgrBubbleSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicProportionalSymbolSeries", IgrGeographicProportionalSymbolSeries);
        TypeRegistrar.register("GeographicProportionalSymbolSeries", GeographicProportionalSymbolSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicSymbolSeriesView = /*@__PURE__*/ (() => {
    class GeographicSymbolSeriesView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            let a = this.b0.l3;
            super.bv();
            a.nv = this.b0.mk;
            a.nz = this.b0.mi;
            a.l2 = this.b0.mc;
            a.mn = this.b0.mu;
            a.l7 = this.b0.mg;
        }
        b2() {
            this.b0.l3.nv = this.b0.mk;
        }
        b1() {
            this.b0.l3.nz = this.b0.mi;
        }
        b8() {
            this.b0.l3.l2 = this.b0.mc;
        }
        b6() {
            this.b0.l3.mn = this.b0.mu;
        }
        b7() {
            this.b0.l3.l7 = this.b0.mg;
        }
        b9() {
            this.b0.l3.no = this.b0.mh;
        }
        cb() {
            this.b0.l3.xAxis = this.b0.bs.nc;
        }
        cc() {
            this.b0.l3.yAxis = this.b0.bs.ne;
        }
        ca() {
            let a = this.b0.l3;
            if (this.b0.bs == null) {
                a.xAxis = null;
                a.yAxis = null;
                return;
            }
            a.xAxis = this.b0.bs.nc;
            a.yAxis = this.b0.bs.ne;
        }
        b4() {
            this.b0.l3.m5 = this.b0.mb;
        }
        b3() {
            this.b0.l3.m1 = this.b0.m5;
        }
        b5() {
            this.b0.l3.m2 = this.b0.m6;
        }
    }
    GeographicSymbolSeriesView.$t = /*@__PURE__*/ markType(GeographicSymbolSeriesView, 'GeographicSymbolSeriesView', HostSeriesView.$);
    return GeographicSymbolSeriesView;
})();
/**
 * @hidden
 */
let GeographicSymbolSeries = /*@__PURE__*/ (() => {
    class GeographicSymbolSeries extends GeographicMapSeriesHost {
        constructor() {
            super();
            this.md = null;
            this.ab = GeographicSymbolSeries.$;
        }
        bf() {
            return new GeographicSymbolSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.me = a;
        }
        l2() {
            return new ScatterSeries();
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.me.ca();
                    break;
                case GeographicSymbolSeries.$$p[1]:
                    this.me.b2();
                    break;
                case GeographicSymbolSeries.$$p[0]:
                    this.me.b1();
                    break;
                case GeographicSymbolSeries.$$p[3]:
                    this.me.b4();
                    break;
                case GeographicSymbolSeries.$$p[7]:
                    this.me.b8();
                    break;
                case GeographicSymbolSeries.$$p[5]:
                    this.me.b6();
                    break;
                case GeographicSymbolSeries.$$p[6]:
                    this.me.b7();
                    break;
                case GeographicSymbolSeries.$$p[8]:
                    this.me.b9();
                    break;
                case "XAxis":
                    this.me.cb();
                    break;
                case "YAxis":
                    this.me.cc();
                    break;
                case GeographicSymbolSeries.$$p[2]:
                    this.me.b3();
                    break;
                case GeographicSymbolSeries.$$p[4]:
                    this.me.b5();
                    break;
            }
        }
    }
    GeographicSymbolSeries.$t = /*@__PURE__*/ markType(GeographicSymbolSeries, 'GeographicSymbolSeries', GeographicMapSeriesHost.$);
    GeographicSymbolSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicSymbolSeries, 'raisePropertyChanged', ['LatitudeMemberPath:mi:mv', [2, null], 'LongitudeMemberPath:mk:mw', [2, null], 'MarkerBrush:m5:mx', [Brush.$], 'MarkerCollisionAvoidance:mb:my', [CollisionAvoidanceType_$type, /*@__PURE__*/ enumGetBox(CollisionAvoidanceType_$type, 0)], 'MarkerOutline:m6:mz', [Brush.$], 'MarkerTemplate:mu:m0', [DataTemplate.$, null], 'MarkerThickness:mg:m1', [1, /*@__PURE__*/ DeviceUtils.g(2)], 'MarkerType:mc:m2', [MarkerType_$type, /*@__PURE__*/ enumGetBox(MarkerType_$type, 2)], 'MaximumMarkers:mh:m3', [1, 400], 'UseLightweightMarkers:mf:m4', [0, false]]);
    return GeographicSymbolSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a ScatterSeries.
*/
class IgrGeographicSymbolSeries extends IgrGeographicMapSeriesHost {
    createImplementation() {
        return new GeographicSymbolSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mi;
    }
    set latitudeMemberPath(v) {
        this.i.mi = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.mk;
    }
    set longitudeMemberPath(v) {
        this.i.mk = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.mc;
    }
    set markerType(v) {
        this.i.mc = ensureEnum(MarkerType_$type, v);
    }
    /**
     * The desired behavior for markers in this series which are placed too close together for the current view, resulting in a collision.
    */
    get markerCollisionAvoidance() {
        return this.i.mb;
    }
    set markerCollisionAvoidance(v) {
        this.i.mb = ensureEnum(CollisionAvoidanceType_$type, v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.mu;
    }
    set markerTemplate(v) {
        this.i.mu = v;
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.m5);
    }
    set markerBrush(v) {
        this.i.m5 = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.m6);
    }
    set markerOutline(v) {
        this.i.m6 = stringToBrush(v);
    }
    /**
     * Gets or sets the maximum number of markerItems displayed by the current series.
     * If more than the specified number of markerItems are visible, the series will automatically
     * choose a representative set.
    */
    get maximumMarkers() {
        return this.i.mh;
    }
    set maximumMarkers(v) {
        this.i.mh = +v;
    }
    /**
     * Gets or sets thickness of the marker outline
    */
    get markerThickness() {
        return this.i.mg;
    }
    set markerThickness(v) {
        this.i.mg = +v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicSymbolSeriesModule {
    static register() {
        IgrScatterSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicSymbolSeries", IgrGeographicSymbolSeries);
        TypeRegistrar.register("GeographicSymbolSeries", GeographicSymbolSeries.$type);
    }
}

/**
 * Base class for geographic series which triangulate XY data prior to rendering.
*/
class IgrGeographicXYTriangulatingSeries extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
    }
    get i() {
        return this._implementation;
    }
    /**
     * Gets or sets the string path specifying the location of the Itf file.
    */
    set triangulationDataSource(value) {
        this._triangulationDataSource = value;
        this.updateTriangulationDataSource();
    }
    get triangulationDataSource() {
        return this._triangulationDataSource;
    }
    updateTriangulationDataSource() {
        if (this._cachedTriangulationDataSource == null) {
            this._cachedTriangulationDataSource = new IgrTriangulationDataSource();
            this.onTriangulationDataSourceImportCompleted = this.onTriangulationDataSourceImportCompleted.bind(this);
            this._cachedTriangulationDataSource.importCompleted = this.onTriangulationDataSourceImportCompleted;
        }
        this._cachedTriangulationDataSource.source = this._triangulationDataSource;
    }
    onTriangulationDataSourceImportCompleted(s, e) {
        this.dataSource = this._cachedTriangulationDataSource.getPointData();
        this.trianglesSource = this._cachedTriangulationDataSource.getTriangleData();
    }
    /**
 * The name of the property from which to extract the Longitude for each item in the ItemsSource.
*/
    get longitudeMemberPath() {
        return this.i.mf;
    }
    set longitudeMemberPath(v) {
        this.i.mf = v;
    }
    /**
     * The name of the property from which to extract the Latitude for each item in the ItemsSource.
    */
    get latitudeMemberPath() {
        return this.i.md;
    }
    set latitudeMemberPath(v) {
        this.i.md = v;
    }
    /**
     * The source of triangulation data.
     * This property is optional.  If it is left as null, the triangulation will be created based on the items in the ItemsSource.  Triangulation is a demanding operation, so the runtime performance will be better when specifying a TriangulationSource, especially when a large number of data items are present.
    */
    get trianglesSource() {
        return this.i.mc;
    }
    set trianglesSource(v) {
        this.i.mc = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath1() {
        return this.i.mi;
    }
    set triangleVertexMemberPath1(v) {
        this.i.mi = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the second vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath2() {
        return this.i.mk;
    }
    set triangleVertexMemberPath2(v) {
        this.i.mk = v;
    }
    /**
     * The name of the property of the TrianglesSource items which, for each triangle, contains the index of the third vertex point in the ItemsSource.
    */
    get triangleVertexMemberPath3() {
        return this.i.mm;
    }
    set triangleVertexMemberPath3(v) {
        this.i.mm = v;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class which draws a colored 2D surface, in a geographic context, based on a triangulation of XY data with numeric values assigned to each point.
*/
class IgrGeographicScatterAreaSeries extends IgrGeographicXYTriangulatingSeries {
    constructor(props) {
        super(props);
        this._triangulationStatusChanged = null;
        this._triangulationStatusChanged_wrapped = null;
    }
    createImplementation() {
        return new GeographicScatterAreaSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property on each data item containing a numeric value which can be converted to a color by the ColorScale.
    */
    get colorMemberPath() {
        return this.i.mz;
    }
    set colorMemberPath(v) {
        this.i.mz = v;
    }
    /**
     * The ColorScale used to resolve the color values of points in the series.
    */
    get colorScale() {
        if (this.i.mv == null) {
            return null;
        }
        if (!this.i.mv.externalObject) {
            let e = IgrColorScale._createFromInternal(this.i.mv);
            if (e) {
                e._implementation = this.i.mv;
            }
            this.i.mv.externalObject = e;
        }
        return this.i.mv.externalObject;
    }
    set colorScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mv = null : this.i.mv = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.colorScale && this.colorScale.name && this.colorScale.name == name) {
            return this.colorScale;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.colorScale && this.colorScale._styling) {
            this.colorScale._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Raised when the status of an ongoing Triangulation has changed.
    */
    get triangulationStatusChanged() {
        return this._triangulationStatusChanged;
    }
    set triangulationStatusChanged(ev) {
        if (this._triangulationStatusChanged_wrapped !== null) {
            this.i.triangulationStatusChanged = delegateRemove(this.i.triangulationStatusChanged, this._triangulationStatusChanged_wrapped);
            this._triangulationStatusChanged_wrapped = null;
            this._triangulationStatusChanged = null;
        }
        this._triangulationStatusChanged = ev;
        this._triangulationStatusChanged_wrapped = (o, e) => {
            let outerArgs = new IgrTriangulationStatusEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeTriangulationStatusChanged) {
                this.beforeTriangulationStatusChanged(this, outerArgs);
            }
            if (this._triangulationStatusChanged) {
                this._triangulationStatusChanged(this, outerArgs);
            }
        };
        this.i.triangulationStatusChanged = delegateCombine(this.i.triangulationStatusChanged, this._triangulationStatusChanged_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicScatterAreaSeriesModule {
    static register() {
        IgrScatterAreaSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicScatterAreaSeries", IgrGeographicScatterAreaSeries);
        TypeRegistrar.register("GeographicScatterAreaSeries", GeographicScatterAreaSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicHighDensityScatterSeriesView = /*@__PURE__*/ (() => {
    class GeographicHighDensityScatterSeriesView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
        bv() {
            super.bv();
            let a = typeCast(HighDensityScatterSeries.$, this.b0.l3);
            a.n4 = this.b0.ms;
            a.n8 = this.b0.mq;
            a.mo = this.b0.mf;
            a.mn = this.b0.me;
            a.c7 = this.b0.md;
            a.ng = this.b0.mh;
            a.nf = this.b0.mg;
        }
        b6() {
            this.b0.l3.n4 = this.b0.ms;
        }
        b5() {
            this.b0.l3.n8 = this.b0.mq;
        }
        cb() {
            this.b0.l3.mo = this.b0.mf;
        }
        b9() {
            this.b0.l3.mn = this.b0.me;
        }
        b7() {
            this.b0.l3.c7 = this.b0.md;
        }
        b4() {
            this.b0.l3.ng = this.b0.mh;
        }
        b2() {
            this.b0.l3.nf = this.b0.mg;
        }
        ca() {
            let a = typeCast(HighDensityScatterSeries.$, this.b0.l3);
            if (this.b0.bs == null) {
                a.l8 = null;
                a.ma = null;
                return;
            }
            a.l8 = this.b0.bs.nc;
            a.ma = this.b0.bs.ne;
        }
        cc() {
            this.b0.l3.l8 = this.b0.bs.nc;
        }
        cd() {
            this.b0.l3.ma = this.b0.bs.ne;
        }
        b3() {
            this.b0.l3.o1 = this.b0.na;
        }
        b1() {
            this.b0.l3.o0 = this.b0.m9;
        }
        b8() {
            this.b0.l3.ns = this.b0.mk;
        }
    }
    GeographicHighDensityScatterSeriesView.$t = /*@__PURE__*/ markType(GeographicHighDensityScatterSeriesView, 'GeographicHighDensityScatterSeriesView', HostSeriesView.$);
    return GeographicHighDensityScatterSeriesView;
})();
/**
 * @hidden
 */
let GeographicHighDensityScatterSeries = /*@__PURE__*/ (() => {
    class GeographicHighDensityScatterSeries extends GeographicMapSeriesHost {
        constructor() {
            super();
            this.mb = null;
            this.progressiveLoadStatusChanged = null;
            this.mj = 0;
            this.ab = GeographicHighDensityScatterSeries.$;
        }
        bf() {
            return new GeographicHighDensityScatterSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.mc = a;
        }
        l2() {
            return new HighDensityScatterSeries();
        }
        get ml() {
            return this.mj;
        }
        set ml(a) {
            let b = this.mj;
            this.mj = a;
            this.raisePropertyChanged("ProgressiveStatus", b, this.mj);
        }
        l8() {
            super.l8();
            let a = this.l3;
            a.progressiveLoadStatusChanged = delegateCombine(a.progressiveLoadStatusChanged, runOn(this, this.my));
        }
        my(a, b) {
            this.ml = b.currentStatus;
            if (this.progressiveLoadStatusChanged != null) {
                this.progressiveLoadStatusChanged(this, b);
            }
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case "SeriesViewer":
                    this.mc.ca();
                    break;
                case GeographicHighDensityScatterSeries.$$p[5]:
                    this.mc.b6();
                    break;
                case GeographicHighDensityScatterSeries.$$p[4]:
                    this.mc.b5();
                    break;
                case GeographicHighDensityScatterSeries.$$p[9]:
                    this.mc.cb();
                    break;
                case GeographicHighDensityScatterSeries.$$p[8]:
                    this.mc.b9();
                    break;
                case GeographicHighDensityScatterSeries.$$p[6]:
                    this.mc.b7();
                    break;
                case "XAxis":
                    this.mc.cc();
                    break;
                case "YAxis":
                    this.mc.cd();
                    break;
                case GeographicHighDensityScatterSeries.$$p[3]:
                    this.mc.b4();
                    break;
                case GeographicHighDensityScatterSeries.$$p[1]:
                    this.mc.b2();
                    break;
                case GeographicHighDensityScatterSeries.$$p[2]:
                    this.mc.b3();
                    break;
                case GeographicHighDensityScatterSeries.$$p[0]:
                    this.mc.b1();
                    break;
                case GeographicHighDensityScatterSeries.$$p[7]:
                    this.mc.b8();
                    break;
            }
        }
        get_dq() {
            return true;
        }
        set_dq(a) {
            super.set_dq(a);
        }
    }
    GeographicHighDensityScatterSeries.$t = /*@__PURE__*/ markType(GeographicHighDensityScatterSeries, 'GeographicHighDensityScatterSeries', GeographicMapSeriesHost.$);
    GeographicHighDensityScatterSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicHighDensityScatterSeries, 'raisePropertyChanged', ['HeatMaximumColor:m9:mz', [Color.$, null], 'HeatMaximum:mg:m0', [1, 50], 'HeatMinimumColor:na:m1', [Color.$, null], 'HeatMinimum:mh:m2', [1, 0], 'LatitudeMemberPath:mq:m3', [2, null], 'LongitudeMemberPath:ms:m4', [2, null], 'MouseOverEnabled:md:m5', [0, false], 'PointExtent:mk:m6', [1, 1], 'ProgressiveLoad:me:m7', [0, true], 'UseBruteForce:mf:m8', [0, false]]);
    return GeographicHighDensityScatterSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Series class for a geographic map with points marked at given locations.
 * This is the geographic equivalent of a HighDensityScatterSeries.
*/
class IgrGeographicHighDensityScatterSeries extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
        this._progressiveLoadStatusChanged = null;
        this._progressiveLoadStatusChanged_wrapped = null;
    }
    createImplementation() {
        return new GeographicHighDensityScatterSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property of ItemsSource items which contains the latitude coordinate of the symbol.
    */
    get latitudeMemberPath() {
        return this.i.mq;
    }
    set latitudeMemberPath(v) {
        this.i.mq = v;
    }
    /**
     * The name of the property of ItemsSource items which contains the longitude coordinate of the symbol.
    */
    get longitudeMemberPath() {
        return this.i.ms;
    }
    set longitudeMemberPath(v) {
        this.i.ms = v;
    }
    /**
     * Gets or sets the whether to use use brute force mode.
    */
    get useBruteForce() {
        return this.i.mf;
    }
    set useBruteForce(v) {
        this.i.mf = ensureBool(v);
    }
    /**
     * Gets or sets the whether to progressively load the data into the chart.
    */
    get progressiveLoad() {
        return this.i.me;
    }
    set progressiveLoad(v) {
        this.i.me = ensureBool(v);
    }
    /**
     * Gets or sets the whether the chart reacts to mouse move events.
    */
    get mouseOverEnabled() {
        return this.i.md;
    }
    set mouseOverEnabled(v) {
        this.i.md = ensureBool(v);
    }
    /**
     * Gets or sets the density value that maps to the minimum heat color.
    */
    get heatMinimum() {
        return this.i.mh;
    }
    set heatMinimum(v) {
        this.i.mh = +v;
    }
    /**
     * Gets or sets the value that maps to the maximum heat color.
    */
    get heatMaximum() {
        return this.i.mg;
    }
    set heatMaximum(v) {
        this.i.mg = +v;
    }
    /**
     * Gets or sets the color to use for the minimum end of the scale.
    */
    get heatMinimumColor() {
        return colorToString(this.i.na);
    }
    set heatMinimumColor(v) {
        this.i.na = stringToColor(v);
    }
    /**
     * Gets or sets the color to use for the maximum end of the scale.
    */
    get heatMaximumColor() {
        return colorToString(this.i.m9);
    }
    set heatMaximumColor(v) {
        this.i.m9 = stringToColor(v);
    }
    /**
     * Gets or sets the the pixel extent of the square data points that are rendered.
    */
    get pointExtent() {
        return this.i.mk;
    }
    set pointExtent(v) {
        this.i.mk = +v;
    }
    /**
     * Represents the current status of the progressive load of the series. It will range from 0 to 100, where 100 is fully loaded.
    */
    get progressiveStatus() {
        return this.i.ml;
    }
    set progressiveStatus(v) {
        this.i.ml = +v;
    }
    /**
     * Raised when the progressive loading state of the series has changed.
    */
    get progressiveLoadStatusChanged() {
        return this._progressiveLoadStatusChanged;
    }
    set progressiveLoadStatusChanged(ev) {
        if (this._progressiveLoadStatusChanged_wrapped !== null) {
            this.i.progressiveLoadStatusChanged = delegateRemove(this.i.progressiveLoadStatusChanged, this._progressiveLoadStatusChanged_wrapped);
            this._progressiveLoadStatusChanged_wrapped = null;
            this._progressiveLoadStatusChanged = null;
        }
        this._progressiveLoadStatusChanged = ev;
        this._progressiveLoadStatusChanged_wrapped = (o, e) => {
            let outerArgs = new IgrProgressiveLoadStatusEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeProgressiveLoadStatusChanged) {
                this.beforeProgressiveLoadStatusChanged(this, outerArgs);
            }
            if (this._progressiveLoadStatusChanged) {
                this._progressiveLoadStatusChanged(this, outerArgs);
            }
        };
        this.i.progressiveLoadStatusChanged = delegateCombine(this.i.progressiveLoadStatusChanged, this._progressiveLoadStatusChanged_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicHighDensityScatterSeriesModule {
    static register() {
        IgrHighDensityScatterSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicHighDensityScatterSeries", IgrGeographicHighDensityScatterSeries);
        TypeRegistrar.register("GeographicHighDensityScatterSeries", GeographicHighDensityScatterSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicContourLineSeriesView = /*@__PURE__*/ (() => {
    class GeographicContourLineSeriesView extends GeographicXYTriangulatingSeriesView {
        constructor(a) {
            super(a);
            this.b8 = null;
            this.b8 = a;
        }
        bv() {
            super.bv();
            if (this.b8.l3 != null) {
                this.b8.mv.nl = this.b8.mx;
                this.b8.mv.nq = this.b8.m0;
            }
        }
        b9() {
            if (this.b8.mv != null) {
                this.b8.mv.nl = this.b8.mx;
            }
        }
        ca() {
            if (this.b8.mv != null) {
                this.b8.mv.nq = this.b8.m0;
            }
        }
    }
    GeographicContourLineSeriesView.$t = /*@__PURE__*/ markType(GeographicContourLineSeriesView, 'GeographicContourLineSeriesView', GeographicXYTriangulatingSeriesView.$);
    return GeographicContourLineSeriesView;
})();
/**
 * @hidden
 */
let GeographicContourLineSeries = /*@__PURE__*/ (() => {
    class GeographicContourLineSeries extends GeographicXYTriangulatingSeries {
        constructor() {
            super();
            this.triangulationStatusChanged = null;
            this.ab = GeographicContourLineSeries.$;
        }
        l8() {
            super.l8();
        }
        l2() {
            this.mv = new ScatterContourSeries();
            let a = this.mv;
            a.triangulationStatusChanged = delegateCombine(a.triangulationStatusChanged, runOn(this, this.m3));
            return this.mv;
        }
        m3(a, b) {
            if (this.triangulationStatusChanged != null) {
                this.triangulationStatusChanged(this, b);
            }
        }
        bf() {
            return new GeographicContourLineSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.my = a;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case GeographicContourLineSeries.$$p[0]:
                    this.my.b9();
                    break;
                case GeographicContourLineSeries.$$p[1]:
                    this.my.ca();
                    break;
                case GeographicContourLineSeries.$$p[2]:
                    this.mv.nj = this.mu;
                    break;
                case "Thickness":
                    this.mv.ey = this.ey;
                    break;
                case "DashArray":
                    this.mv.lc = this.lc;
                    break;
                case "DashCap":
                    this.mv.ld = this.ld;
                    break;
                case "MiterLimit":
                    this.mv.es = this.es;
                    break;
            }
        }
    }
    GeographicContourLineSeries.$t = /*@__PURE__*/ markType(GeographicContourLineSeries, 'GeographicContourLineSeries', GeographicXYTriangulatingSeries.$);
    GeographicContourLineSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, GeographicContourLineSeries, 'raisePropertyChanged', ['FillScale:mx:m4', [ValueBrushScale.$, null], 'ValueMemberPath:m0:m5', [2, "value"], 'ValueResolver:mu:m6', [ContourValueResolver.$, null]]);
    return GeographicContourLineSeries;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/**
 * Represents a class for Geographic Contour Series displayed on a map.
*/
class IgrGeographicContourLineSeries extends IgrGeographicXYTriangulatingSeries {
    constructor(props) {
        super(props);
        this._triangulationStatusChanged = null;
        this._triangulationStatusChanged_wrapped = null;
    }
    createImplementation() {
        return new GeographicContourLineSeries();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    /**
     * The name of the property from which to retrieve the numeric values from the ItemsSource items.
    */
    get valueMemberPath() {
        return this.i.m0;
    }
    set valueMemberPath(v) {
        this.i.m0 = v;
    }
    /**
     * The ValueBrushScale to use when determining Brushes for each contour line, based on the values found in ValueMemberPath.
    */
    get fillScale() {
        if (this.i.mx == null) {
            return null;
        }
        if (!this.i.mx.externalObject) {
            let e = IgrValueBrushScale._createFromInternal(this.i.mx);
            if (e) {
                e._implementation = this.i.mx;
            }
            this.i.mx.externalObject = e;
        }
        return this.i.mx.externalObject;
    }
    set fillScale(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mx = null : this.i.mx = v.i;
    }
    /**
     * The ContourValueResolver used to determine the numeric values of contours.
    */
    get valueResolver() {
        if (this.i.mu == null) {
            return null;
        }
        if (!this.i.mu.externalObject) {
            let e = IgrContourValueResolver._createFromInternal(this.i.mu);
            if (e) {
                e._implementation = this.i.mu;
            }
            this.i.mu.externalObject = e;
        }
        return this.i.mu.externalObject;
    }
    set valueResolver(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.mu = null : this.i.mu = v.i;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.fillScale && this.fillScale.name && this.fillScale.name == name) {
            return this.fillScale;
        }
        if (this.valueResolver && this.valueResolver.name && this.valueResolver.name == name) {
            return this.valueResolver;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.fillScale && this.fillScale._styling) {
            this.fillScale._styling(container, component, this);
        }
        if (this.valueResolver && this.valueResolver._styling) {
            this.valueResolver._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Raised when the status of an ongoing Triangulation has changed.
    */
    get triangulationStatusChanged() {
        return this._triangulationStatusChanged;
    }
    set triangulationStatusChanged(ev) {
        if (this._triangulationStatusChanged_wrapped !== null) {
            this.i.triangulationStatusChanged = delegateRemove(this.i.triangulationStatusChanged, this._triangulationStatusChanged_wrapped);
            this._triangulationStatusChanged_wrapped = null;
            this._triangulationStatusChanged = null;
        }
        this._triangulationStatusChanged = ev;
        this._triangulationStatusChanged_wrapped = (o, e) => {
            let outerArgs = new IgrTriangulationStatusEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeTriangulationStatusChanged) {
                this.beforeTriangulationStatusChanged(this, outerArgs);
            }
            if (this._triangulationStatusChanged) {
                this._triangulationStatusChanged(this, outerArgs);
            }
        };
        this.i.triangulationStatusChanged = delegateCombine(this.i.triangulationStatusChanged, this._triangulationStatusChanged_wrapped);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicContourLineSeriesModule {
    static register() {
        IgrScatterContourSeriesModule.register();
        TypeRegistrar.registerCons("IgrGeographicContourLineSeries", IgrGeographicContourLineSeries);
        TypeRegistrar.register("GeographicContourLineSeries", GeographicContourLineSeries.$type);
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE: you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
class IgrGeographicMapModule {
    static register() {
        IgrGeographicShapeSeriesModule.register();
        IgrGeographicPolylineSeriesModule.register();
        IgrTileGeneratorMapImageryModule.register();
        IgrHeatTileGeneratorModule.register();
        IgrGeographicTileSeriesModule.register();
        IgrSizeScaleModule.register();
        IgrValueBrushScaleModule.register();
        IgrCustomPaletteColorScaleModule.register();
        IgrGeographicProportionalSymbolSeriesModule.register();
        IgrGeographicSymbolSeriesModule.register();
        IgrGeographicScatterAreaSeriesModule.register();
        IgrGeographicHighDensityScatterSeriesModule.register();
        IgrGeographicContourLineSeriesModule.register();
        IgrGeographicMapCoreModule.register();
        IgrShapeDataSourceModule.register();
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TokenResponseModel = /*@__PURE__*/ (() => {
    class TokenResponseModel extends Base {
        constructor() {
            super(...arguments);
            this._token = null;
            this._expires = 0;
            this._ssl = false;
        }
        get token() {
            return this._token;
        }
        set token(a) {
            this._token = a;
        }
        get expires() {
            return this._expires;
        }
        set expires(a) {
            this._expires = a;
        }
        get ssl() {
            return this._ssl;
        }
        set ssl(a) {
            this._ssl = a;
        }
    }
    TokenResponseModel.$t = /*@__PURE__*/ markType(TokenResponseModel, 'TokenResponseModel');
    return TokenResponseModel;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let MapServerResponseModel = /*@__PURE__*/ (() => {
    class MapServerResponseModel extends Base {
        constructor() {
            super(...arguments);
            this._name = null;
            this._tileInfo = null;
        }
        get name() {
            return this._name;
        }
        set name(a) {
            this._name = a;
        }
        get tileInfo() {
            return this._tileInfo;
        }
        set tileInfo(a) {
            this._tileInfo = a;
        }
    }
    MapServerResponseModel.$t = /*@__PURE__*/ markType(MapServerResponseModel, 'MapServerResponseModel');
    return MapServerResponseModel;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let TileInfoResponseModel = /*@__PURE__*/ (() => {
    class TileInfoResponseModel extends Base {
        constructor() {
            super(...arguments);
            this._lods = null;
        }
        get lods() {
            return this._lods;
        }
        set lods(a) {
            this._lods = a;
        }
    }
    TileInfoResponseModel.$t = /*@__PURE__*/ markType(TileInfoResponseModel, 'TileInfoResponseModel');
    return TileInfoResponseModel;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let LevelOfDetailResponseModel = /*@__PURE__*/ (() => {
    class LevelOfDetailResponseModel extends Base {
        constructor() {
            super(...arguments);
            this._level = 0;
            this._resolution = 0;
            this._scale = 0;
        }
        get level() {
            return this._level;
        }
        set level(a) {
            this._level = a;
        }
        get resolution() {
            return this._resolution;
        }
        set resolution(a) {
            this._resolution = a;
        }
        get scale() {
            return this._scale;
        }
        set scale(a) {
            this._scale = a;
        }
    }
    LevelOfDetailResponseModel.$t = /*@__PURE__*/ markType(LevelOfDetailResponseModel, 'LevelOfDetailResponseModel');
    return LevelOfDetailResponseModel;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicProportionalSymbolSeriesBaseView = /*@__PURE__*/ (() => {
    class GeographicProportionalSymbolSeriesBaseView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
    }
    GeographicProportionalSymbolSeriesBaseView.$t = /*@__PURE__*/ markType(GeographicProportionalSymbolSeriesBaseView, 'GeographicProportionalSymbolSeriesBaseView', HostSeriesView.$);
    return GeographicProportionalSymbolSeriesBaseView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicShapeSeriesBaseBaseView = /*@__PURE__*/ (() => {
    class GeographicShapeSeriesBaseBaseView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
    }
    GeographicShapeSeriesBaseBaseView.$t = /*@__PURE__*/ markType(GeographicShapeSeriesBaseBaseView, 'GeographicShapeSeriesBaseBaseView', HostSeriesView.$);
    return GeographicShapeSeriesBaseBaseView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicSymbolSeriesBaseView = /*@__PURE__*/ (() => {
    class GeographicSymbolSeriesBaseView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
    }
    GeographicSymbolSeriesBaseView.$t = /*@__PURE__*/ markType(GeographicSymbolSeriesBaseView, 'GeographicSymbolSeriesBaseView', HostSeriesView.$);
    return GeographicSymbolSeriesBaseView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicXYTriangulatingSeriesBaseView = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeriesBaseView extends HostSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b0 = a;
        }
    }
    GeographicXYTriangulatingSeriesBaseView.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeriesBaseView, 'GeographicXYTriangulatingSeriesBaseView', HostSeriesView.$);
    return GeographicXYTriangulatingSeriesBaseView;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let ImageryMetadata = /*@__PURE__*/ (() => {
    class ImageryMetadata extends Base {
        constructor() {
            super();
            this.b = null;
            this.a = null;
            this.a = new List$1(String_$type, 0);
        }
    }
    ImageryMetadata.$t = /*@__PURE__*/ markType(ImageryMetadata, 'ImageryMetadata');
    return ImageryMetadata;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BingResourceSet = /*@__PURE__*/ (() => {
    class BingResourceSet extends Base {
        constructor() {
            super();
            this.a = null;
            this.a = new List$1(ImageryMetadata.$, 0);
        }
    }
    BingResourceSet.$t = /*@__PURE__*/ markType(BingResourceSet, 'BingResourceSet');
    return BingResourceSet;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let BingResponse = /*@__PURE__*/ (() => {
    class BingResponse extends Base {
        constructor() {
            super();
            this.a = null;
            this.a = new List$1(BingResourceSet.$, 0);
        }
    }
    BingResponse.$t = /*@__PURE__*/ markType(BingResponse, 'BingResponse');
    return BingResponse;
})();

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicProportionalSymbolSeriesBase = /*@__PURE__*/ (() => {
    class GeographicProportionalSymbolSeriesBase extends GeographicMapSeriesHost {
    }
    GeographicProportionalSymbolSeriesBase.$t = /*@__PURE__*/ markType(GeographicProportionalSymbolSeriesBase, 'GeographicProportionalSymbolSeriesBase', GeographicMapSeriesHost.$);
    return GeographicProportionalSymbolSeriesBase;
})();

class IgrGeographicProportionalSymbolSeriesBase extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicShapeSeriesBaseBase = /*@__PURE__*/ (() => {
    class GeographicShapeSeriesBaseBase extends GeographicMapSeriesHost {
    }
    GeographicShapeSeriesBaseBase.$t = /*@__PURE__*/ markType(GeographicShapeSeriesBaseBase, 'GeographicShapeSeriesBaseBase', GeographicMapSeriesHost.$);
    return GeographicShapeSeriesBaseBase;
})();

class IgrGeographicShapeSeriesBaseBase extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicSymbolSeriesBase = /*@__PURE__*/ (() => {
    class GeographicSymbolSeriesBase extends GeographicMapSeriesHost {
    }
    GeographicSymbolSeriesBase.$t = /*@__PURE__*/ markType(GeographicSymbolSeriesBase, 'GeographicSymbolSeriesBase', GeographicMapSeriesHost.$);
    return GeographicSymbolSeriesBase;
})();

class IgrGeographicSymbolSeriesBase extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
/**
 * @hidden
 */
let GeographicXYTriangulatingSeriesBase = /*@__PURE__*/ (() => {
    class GeographicXYTriangulatingSeriesBase extends GeographicMapSeriesHost {
    }
    GeographicXYTriangulatingSeriesBase.$t = /*@__PURE__*/ markType(GeographicXYTriangulatingSeriesBase, 'GeographicXYTriangulatingSeriesBase', GeographicMapSeriesHost.$);
    return GeographicXYTriangulatingSeriesBase;
})();

class IgrGeographicXYTriangulatingSeriesBase extends IgrGeographicMapSeriesHost {
    constructor(props) {
        super(props);
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
}

/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

export { ArcGISOnlineMapImagery, BingMapsImageryStyle, BingMapsImageryStyle_$type, BingMapsMapImagery, BingMapsMapImageryView, BingResourceSet, BingResponse, CustomMapImagery, GeographicContourLineSeries, GeographicContourLineSeriesView, GeographicHighDensityScatterSeries, GeographicHighDensityScatterSeriesView, GeographicMapImagery, GeographicMapImageryView, GeographicMapSeriesHost, GeographicPolylineSeries, GeographicPolylineSeriesView, GeographicProportionalSymbolSeries, GeographicProportionalSymbolSeriesBase, GeographicProportionalSymbolSeriesBaseView, GeographicProportionalSymbolSeriesView, GeographicScatterAreaSeries, GeographicScatterAreaSeriesView, GeographicShapeSeries, GeographicShapeSeriesBase, GeographicShapeSeriesBaseBase, GeographicShapeSeriesBaseBaseView, GeographicShapeSeriesBaseView, GeographicShapeSeriesView, GeographicSymbolSeries, GeographicSymbolSeriesBase, GeographicSymbolSeriesBaseView, GeographicSymbolSeriesView, GeographicTileSeries, GeographicXYTriangulatingSeries, GeographicXYTriangulatingSeriesBase, GeographicXYTriangulatingSeriesBaseView, GeographicXYTriangulatingSeriesView, HostSeriesView, IgrArcGISOnlineMapImagery, IgrArcGISOnlineMapImageryModule, IgrBingMapsMapImagery, IgrBingMapsMapImageryModule, IgrCustomMapImagery, IgrCustomMapImageryModule, IgrGeographicContourLineSeries, IgrGeographicContourLineSeriesModule, IgrGeographicHighDensityScatterSeries, IgrGeographicHighDensityScatterSeriesModule, IgrGeographicMap, IgrGeographicMapCoreModule, IgrGeographicMapImagery, IgrGeographicMapModule, IgrGeographicMapSeriesHost, IgrGeographicPolylineSeries, IgrGeographicPolylineSeriesModule, IgrGeographicProportionalSymbolSeries, IgrGeographicProportionalSymbolSeriesBase, IgrGeographicProportionalSymbolSeriesModule, IgrGeographicScatterAreaSeries, IgrGeographicScatterAreaSeriesModule, IgrGeographicShapeSeries, IgrGeographicShapeSeriesBase, IgrGeographicShapeSeriesBaseBase, IgrGeographicShapeSeriesModule, IgrGeographicSymbolSeries, IgrGeographicSymbolSeriesBase, IgrGeographicSymbolSeriesModule, IgrGeographicTileSeries, IgrGeographicTileSeriesModule, IgrGeographicXYTriangulatingSeries, IgrGeographicXYTriangulatingSeriesBase, IgrImageTilesReadyEventArgs, IgrImagesChangedEventArgs, IgrOpenStreetMapImagery, IgrOpenStreetMapImageryModule, IgrSubDomainsCollection, IgrTileGeneratorMapImagery, IgrTileGeneratorMapImageryModule, IgrTileSeries, IgrTileSeriesModule, ImageTilesReadyEventArgs, ImageryMetadata, ImagesChangedEventArgs, LevelOfDetailResponseModel, MapResizeBehavior, MapResizeBehavior_$type, MapServerResponseModel, OpenStreetMapImagery, SphericalMercatorHorizontalScaler, SphericalMercatorVerticalScaler, SubDomainsCollection, TileGeneratorMapImagery, TileInfoResponseModel, TileSeries, TileSeriesView, TokenResponseModel, XamGeographicMap, XamGeographicMapView };
//# sourceMappingURL=igniteui-react-maps.js.map
